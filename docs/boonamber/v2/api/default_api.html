<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>boonamber.v2.api.default_api API documentation</title>
<meta name="description" content="Amber API Server â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>boonamber.v2.api.default_api</code></h1>
</header>
<section id="section-intro">
<p>Amber API Server</p>
<p>Boon Logic Amber API server
# noqa: E501</p>
<p>OpenAPI spec version: 2.0.0</p>
<p>Generated by: <a href="https://github.com/swagger-api/swagger-codegen.git">https://github.com/swagger-api/swagger-codegen.git</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf-8

&#34;&#34;&#34;
    Amber API Server

    Boon Logic Amber API server  # noqa: E501

    OpenAPI spec version: 2.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
&#34;&#34;&#34;

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from boonamber.v2.api_client import ApiClient


class DefaultApi(object):
    &#34;&#34;&#34;NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    &#34;&#34;&#34;

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_model(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;delete a model  # noqa: E501

        Permanently delete the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_model(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: DeleteModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.delete_model_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def delete_model_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;delete a model  # noqa: E501

        Permanently delete the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_model_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: DeleteModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method delete_model&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `delete_model`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}&#39;, &#39;DELETE&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;DeleteModelResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get model metadata  # noqa: E501

        Return metadata for the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get model metadata  # noqa: E501

        Return metadata for the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostModelResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_config(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get model configuration  # noqa: E501

        Get the configuration of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_config(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: PostConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_config_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get model configuration  # noqa: E501

        Get the configuration of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_config_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: PostConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_config&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_config`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/config&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostConfigResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_nano_status(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get current nano status of the model  # noqa: E501

        Get the current nano state of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_nano_status(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetNanoStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_nano_status_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_nano_status_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_nano_status_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get current nano status of the model  # noqa: E501

        Get the current nano state of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_nano_status_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetNanoStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_nano_status&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_nano_status`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/status/nano&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetNanoStatusResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_pretrain(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get pretraining progress  # noqa: E501

        Get the pretraining status of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_pretrain(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetPretrainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_pretrain_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_pretrain_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_pretrain_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get pretraining progress  # noqa: E501

        Get the pretraining status of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_pretrain_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetPretrainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_pretrain&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_pretrain`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/pretrain&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetPretrainResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_root_cause(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;perform root cause analysis  # noqa: E501

        Return a measure of the significance of each feature in the creation of a cluster. The values range from 0 to 1 where a relatively high value represents a feature that was influential in creating the new cluster. No conclusions can be drawn from values close to zero. This measure can be computed for existing clusters or for individual vectors directly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_root_cause(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :param str clusters: Clusters to analyze (list of comma-separated integers).
        :param str vectors: Vectors to analyze, as a flat list of comma-separated floats. Number of values must be a multiple of the configured number of features.
        :return: GetRootCauseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_root_cause_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_root_cause_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_root_cause_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;perform root cause analysis  # noqa: E501

        Return a measure of the significance of each feature in the creation of a cluster. The values range from 0 to 1 where a relatively high value represents a feature that was influential in creating the new cluster. No conclusions can be drawn from values close to zero. This measure can be computed for existing clusters or for individual vectors directly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_root_cause_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :param str clusters: Clusters to analyze (list of comma-separated integers).
        :param str vectors: Vectors to analyze, as a flat list of comma-separated floats. Number of values must be a multiple of the configured number of features.
        :return: GetRootCauseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;, &#39;clusters&#39;, &#39;vectors&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_root_cause&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_root_cause`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []
        if &#39;clusters&#39; in params:
            query_params.append((&#39;clusters&#39;, params[&#39;clusters&#39;]))  # noqa: E501
        if &#39;vectors&#39; in params:
            query_params.append((&#39;vectors&#39;, params[&#39;vectors&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/rootCause&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetRootCauseResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_status(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get current status of the model  # noqa: E501

        Get the current state and learning progress of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_status(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_status_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_status_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_status_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get current status of the model  # noqa: E501

        Get the current state and learning progress of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_status_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_status&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_status`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/status&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetStatusResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_summary(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get the summation of a model  # noqa: E501

        Get the current summation of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_summary(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_summary_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_summary_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_summary_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get the summation of a model  # noqa: E501

        Get the current summation of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_summary_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_summary&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_summary`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/summary&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetSummaryResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_models(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;list all models  # noqa: E501

        Return `id` and `label` for all models belonging to the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_models(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str verbose: If `true`, include full model metadata.
        :return: GetModelsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_models_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_models_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_models_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;list all models  # noqa: E501

        Return `id` and `label` for all models belonging to the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_models_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str verbose: If `true`, include full model metadata.
        :return: GetModelsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;verbose&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_models&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if &#39;verbose&#39; in params:
            header_params[&#39;verbose&#39;] = params[&#39;verbose&#39;]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetModelsResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_version(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get version information  # noqa: E501

        Return version information for the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_version(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :return: GetVersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_version_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_version_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_version_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get version information  # noqa: E501

        Return version information for the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_version_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :return: GetVersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = []  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_version&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/version&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetVersionResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;create a model  # noqa: E501

        Create a new model and return its unique identifier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostModelRequest body: initial metadata for new model (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_model_with_http_info(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;create a model  # noqa: E501

        Create a new model and return its unique identifier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_with_http_info(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostModelRequest body: initial metadata for new model (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_model`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostModelResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_config(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;configure a model  # noqa: E501

        Configure the specified model. Wipes all progress and puts the model in the `Buffering` state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_config(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :param PostConfigRequest body: configuration to apply
        :return: PostConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def post_model_config_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;configure a model  # noqa: E501

        Configure the specified model. Wipes all progress and puts the model in the `Buffering` state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_config_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :param PostConfigRequest body: configuration to apply
        :return: PostConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;, &#39;body&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_config&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_config`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/config&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostConfigResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_data(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;send data to model and get back results  # noqa: E501

        Send data to the specified model, and get back the resulting analytics and model status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_data(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostDataRequest body: data vector or vectors as a flattened list of comma-separated values (required)
        :param str model_id: (required)
        :return: PostDataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def post_model_data_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;send data to model and get back results  # noqa: E501

        Send data to the specified model, and get back the resulting analytics and model status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_data_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostDataRequest body: data vector or vectors as a flattened list of comma-separated values (required)
        :param str model_id: (required)
        :return: PostDataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_data&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_data`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_data`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/data&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostDataResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_learning(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update model configuration and re-enable learning  # noqa: E501

        Update model configuration and re-enable learning  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_learning(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostLearningRequest body: updates to apply (required)
        :param str model_id: (required)
        :return: PostLearningResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_learning_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_learning_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def post_model_learning_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update model configuration and re-enable learning  # noqa: E501

        Update model configuration and re-enable learning  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_learning_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostLearningRequest body: updates to apply (required)
        :param str model_id: (required)
        :return: PostLearningResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_learning&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_learning`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_learning`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/learning&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostLearningResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_outage(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;call this after a data outage before resuming streaming  # noqa: E501

        Resets the streaming window generated by `streamingWindow`. This endpoint should be called after a data outage before resuming streaming.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_outage(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_outage_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_outage_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def post_model_outage_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;call this after a data outage before resuming streaming  # noqa: E501

        Resets the streaming window generated by `streamingWindow`. This endpoint should be called after a data outage before resuming streaming.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_outage_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_outage&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_outage`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/outage&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;Error&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_pretrain(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;pretrain model with an existing dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_pretrain(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostPretrainRequest body: Data to use for pretraining. (required)
        :param str model_id: (required)
        :param str chunkspec: Chunk specifier for chunked uploads. In a chunked upload, each request is sent with a `chunkspec` of the form `1:3`, `2:10`, `7:7`, etc. where the first number is the index for the chunk being uploaded (1-based) and the second number is the total number of chunks in the transaction. The chunks may be uploaded in any order. Pretraining starts once all chunks have been received.
        :param str txn_id: Transaction id for chunked uploads. The response body for the first request in a chunked upload will contain a `txnId` which uniquely identifies the chunking transaction across multiple requests. That `txnId` must be included in the header of all remaining chunks uploaded in the transaction.
        :return: PostPretrainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_pretrain_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_pretrain_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def post_model_pretrain_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;pretrain model with an existing dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_pretrain_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostPretrainRequest body: Data to use for pretraining. (required)
        :param str model_id: (required)
        :param str chunkspec: Chunk specifier for chunked uploads. In a chunked upload, each request is sent with a `chunkspec` of the form `1:3`, `2:10`, `7:7`, etc. where the first number is the index for the chunk being uploaded (1-based) and the second number is the total number of chunks in the transaction. The chunks may be uploaded in any order. Pretraining starts once all chunks have been received.
        :param str txn_id: Transaction id for chunked uploads. The response body for the first request in a chunked upload will contain a `txnId` which uniquely identifies the chunking transaction across multiple requests. That `txnId` must be included in the header of all remaining chunks uploaded in the transaction.
        :return: PostPretrainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;, &#39;chunkspec&#39;, &#39;txn_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_pretrain&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_pretrain`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_pretrain`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}
        if &#39;chunkspec&#39; in params:
            header_params[&#39;chunkspec&#39;] = params[&#39;chunkspec&#39;]  # noqa: E501
        if &#39;txn_id&#39; in params:
            header_params[&#39;txnId&#39;] = params[&#39;txn_id&#39;]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/pretrain&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostPretrainResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_oauth2_access(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;request an API token given license and secret key  # noqa: E501

        Request an Oauth2 Bearer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_oauth2_access(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostOauth2AccessRequest body: Amber account credentials (required)
        :return: PostOauth2AccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_oauth2_access_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_oauth2_access_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_oauth2_access_with_http_info(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;request an API token given license and secret key  # noqa: E501

        Request an Oauth2 Bearer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_oauth2_access_with_http_info(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostOauth2AccessRequest body: Amber account credentials (required)
        :return: PostOauth2AccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_oauth2_access&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_oauth2_access`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            &#39;/oauth2/access&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostOauth2AccessResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_oauth2_refresh(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;request an API token given a refresh token  # noqa: E501

        Request an Oauth2 Bearer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_oauth2_refresh(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostOauth2RefreshRequest body: Amber account credentials (required)
        :return: PostOauth2RefreshResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_oauth2_refresh_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_oauth2_refresh_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_oauth2_refresh_with_http_info(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;request an API token given a refresh token  # noqa: E501

        Request an Oauth2 Bearer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_oauth2_refresh_with_http_info(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostOauth2RefreshRequest body: Amber account credentials (required)
        :return: PostOauth2RefreshResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_oauth2_refresh&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_oauth2_refresh`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            &#39;/oauth2/refresh&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostOauth2RefreshResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def put_model(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update model metadata  # noqa: E501

        Update metadata for the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.put_model(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PutModelRequest body: updates to apply (required)
        :param str model_id: (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.put_model_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_model_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def put_model_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update model metadata  # noqa: E501

        Update metadata for the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.put_model_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PutModelRequest body: updates to apply (required)
        :param str model_id: (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method put_model&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `put_model`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `put_model`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}&#39;, &#39;PUT&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostModelResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def put_model_data(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update fusion vector and get back results  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.put_model_data(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PutDataRequest body: updates to the fusion vector (required)
        :param str model_id: (required)
        :return: PutDataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.put_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def put_model_data_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update fusion vector and get back results  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.put_model_data_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PutDataRequest body: updates to the fusion vector (required)
        :param str model_id: (required)
        :return: PutDataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method put_model_data&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `put_model_data`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `put_model_data`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/data&#39;, &#39;PUT&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PutDataResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="boonamber.v2.api.default_api.DefaultApi"><code class="flex name class">
<span>class <span class="ident">DefaultApi</span></span>
<span>(</span><span>api_client=None)</span>
</code></dt>
<dd>
<div class="desc"><p>NOTE: This class is auto generated by the swagger code generator program.</p>
<p>Do not edit the class manually.
Ref: <a href="https://github.com/swagger-api/swagger-codegen">https://github.com/swagger-api/swagger-codegen</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DefaultApi(object):
    &#34;&#34;&#34;NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    &#34;&#34;&#34;

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_model(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;delete a model  # noqa: E501

        Permanently delete the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_model(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: DeleteModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.delete_model_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def delete_model_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;delete a model  # noqa: E501

        Permanently delete the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_model_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: DeleteModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method delete_model&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `delete_model`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}&#39;, &#39;DELETE&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;DeleteModelResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get model metadata  # noqa: E501

        Return metadata for the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get model metadata  # noqa: E501

        Return metadata for the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostModelResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_config(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get model configuration  # noqa: E501

        Get the configuration of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_config(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: PostConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_config_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get model configuration  # noqa: E501

        Get the configuration of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_config_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: PostConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_config&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_config`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/config&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostConfigResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_nano_status(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get current nano status of the model  # noqa: E501

        Get the current nano state of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_nano_status(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetNanoStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_nano_status_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_nano_status_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_nano_status_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get current nano status of the model  # noqa: E501

        Get the current nano state of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_nano_status_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetNanoStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_nano_status&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_nano_status`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/status/nano&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetNanoStatusResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_pretrain(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get pretraining progress  # noqa: E501

        Get the pretraining status of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_pretrain(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetPretrainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_pretrain_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_pretrain_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_pretrain_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get pretraining progress  # noqa: E501

        Get the pretraining status of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_pretrain_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetPretrainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_pretrain&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_pretrain`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/pretrain&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetPretrainResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_root_cause(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;perform root cause analysis  # noqa: E501

        Return a measure of the significance of each feature in the creation of a cluster. The values range from 0 to 1 where a relatively high value represents a feature that was influential in creating the new cluster. No conclusions can be drawn from values close to zero. This measure can be computed for existing clusters or for individual vectors directly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_root_cause(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :param str clusters: Clusters to analyze (list of comma-separated integers).
        :param str vectors: Vectors to analyze, as a flat list of comma-separated floats. Number of values must be a multiple of the configured number of features.
        :return: GetRootCauseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_root_cause_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_root_cause_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_root_cause_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;perform root cause analysis  # noqa: E501

        Return a measure of the significance of each feature in the creation of a cluster. The values range from 0 to 1 where a relatively high value represents a feature that was influential in creating the new cluster. No conclusions can be drawn from values close to zero. This measure can be computed for existing clusters or for individual vectors directly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_root_cause_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :param str clusters: Clusters to analyze (list of comma-separated integers).
        :param str vectors: Vectors to analyze, as a flat list of comma-separated floats. Number of values must be a multiple of the configured number of features.
        :return: GetRootCauseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;, &#39;clusters&#39;, &#39;vectors&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_root_cause&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_root_cause`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []
        if &#39;clusters&#39; in params:
            query_params.append((&#39;clusters&#39;, params[&#39;clusters&#39;]))  # noqa: E501
        if &#39;vectors&#39; in params:
            query_params.append((&#39;vectors&#39;, params[&#39;vectors&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/rootCause&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetRootCauseResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_status(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get current status of the model  # noqa: E501

        Get the current state and learning progress of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_status(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_status_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_status_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_status_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get current status of the model  # noqa: E501

        Get the current state and learning progress of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_status_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_status&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_status`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/status&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetStatusResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_model_summary(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get the summation of a model  # noqa: E501

        Get the current summation of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_summary(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_model_summary_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_summary_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_summary_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get the summation of a model  # noqa: E501

        Get the current summation of the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_model_summary_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: GetSummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_model_summary&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_summary`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/summary&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetSummaryResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_models(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;list all models  # noqa: E501

        Return `id` and `label` for all models belonging to the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_models(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str verbose: If `true`, include full model metadata.
        :return: GetModelsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_models_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_models_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_models_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;list all models  # noqa: E501

        Return `id` and `label` for all models belonging to the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_models_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str verbose: If `true`, include full model metadata.
        :return: GetModelsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;verbose&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_models&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if &#39;verbose&#39; in params:
            header_params[&#39;verbose&#39;] = params[&#39;verbose&#39;]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetModelsResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_version(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get version information  # noqa: E501

        Return version information for the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_version(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :return: GetVersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.get_version_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_version_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_version_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get version information  # noqa: E501

        Return version information for the API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_version_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :return: GetVersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = []  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_version&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/version&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;GetVersionResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;create a model  # noqa: E501

        Create a new model and return its unique identifier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostModelRequest body: initial metadata for new model (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_model_with_http_info(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;create a model  # noqa: E501

        Create a new model and return its unique identifier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_with_http_info(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostModelRequest body: initial metadata for new model (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_model`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostModelResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_config(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;configure a model  # noqa: E501

        Configure the specified model. Wipes all progress and puts the model in the `Buffering` state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_config(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :param PostConfigRequest body: configuration to apply
        :return: PostConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def post_model_config_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;configure a model  # noqa: E501

        Configure the specified model. Wipes all progress and puts the model in the `Buffering` state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_config_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :param PostConfigRequest body: configuration to apply
        :return: PostConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;, &#39;body&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_config&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_config`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/config&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostConfigResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_data(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;send data to model and get back results  # noqa: E501

        Send data to the specified model, and get back the resulting analytics and model status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_data(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostDataRequest body: data vector or vectors as a flattened list of comma-separated values (required)
        :param str model_id: (required)
        :return: PostDataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def post_model_data_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;send data to model and get back results  # noqa: E501

        Send data to the specified model, and get back the resulting analytics and model status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_data_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostDataRequest body: data vector or vectors as a flattened list of comma-separated values (required)
        :param str model_id: (required)
        :return: PostDataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_data&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_data`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_data`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/data&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostDataResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_learning(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update model configuration and re-enable learning  # noqa: E501

        Update model configuration and re-enable learning  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_learning(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostLearningRequest body: updates to apply (required)
        :param str model_id: (required)
        :return: PostLearningResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_learning_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_learning_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def post_model_learning_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update model configuration and re-enable learning  # noqa: E501

        Update model configuration and re-enable learning  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_learning_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostLearningRequest body: updates to apply (required)
        :param str model_id: (required)
        :return: PostLearningResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_learning&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_learning`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_learning`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/learning&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostLearningResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_outage(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;call this after a data outage before resuming streaming  # noqa: E501

        Resets the streaming window generated by `streamingWindow`. This endpoint should be called after a data outage before resuming streaming.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_outage(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_outage_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_outage_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def post_model_outage_with_http_info(self, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;call this after a data outage before resuming streaming  # noqa: E501

        Resets the streaming window generated by `streamingWindow`. This endpoint should be called after a data outage before resuming streaming.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_outage_with_http_info(model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param str model_id: (required)
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_outage&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_outage`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/outage&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;Error&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_model_pretrain(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;pretrain model with an existing dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_pretrain(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostPretrainRequest body: Data to use for pretraining. (required)
        :param str model_id: (required)
        :param str chunkspec: Chunk specifier for chunked uploads. In a chunked upload, each request is sent with a `chunkspec` of the form `1:3`, `2:10`, `7:7`, etc. where the first number is the index for the chunk being uploaded (1-based) and the second number is the total number of chunks in the transaction. The chunks may be uploaded in any order. Pretraining starts once all chunks have been received.
        :param str txn_id: Transaction id for chunked uploads. The response body for the first request in a chunked upload will contain a `txnId` which uniquely identifies the chunking transaction across multiple requests. That `txnId` must be included in the header of all remaining chunks uploaded in the transaction.
        :return: PostPretrainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_model_pretrain_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_pretrain_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def post_model_pretrain_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;pretrain model with an existing dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_model_pretrain_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostPretrainRequest body: Data to use for pretraining. (required)
        :param str model_id: (required)
        :param str chunkspec: Chunk specifier for chunked uploads. In a chunked upload, each request is sent with a `chunkspec` of the form `1:3`, `2:10`, `7:7`, etc. where the first number is the index for the chunk being uploaded (1-based) and the second number is the total number of chunks in the transaction. The chunks may be uploaded in any order. Pretraining starts once all chunks have been received.
        :param str txn_id: Transaction id for chunked uploads. The response body for the first request in a chunked upload will contain a `txnId` which uniquely identifies the chunking transaction across multiple requests. That `txnId` must be included in the header of all remaining chunks uploaded in the transaction.
        :return: PostPretrainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;, &#39;chunkspec&#39;, &#39;txn_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_model_pretrain&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_pretrain`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_pretrain`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}
        if &#39;chunkspec&#39; in params:
            header_params[&#39;chunkspec&#39;] = params[&#39;chunkspec&#39;]  # noqa: E501
        if &#39;txn_id&#39; in params:
            header_params[&#39;txnId&#39;] = params[&#39;txn_id&#39;]  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/pretrain&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostPretrainResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_oauth2_access(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;request an API token given license and secret key  # noqa: E501

        Request an Oauth2 Bearer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_oauth2_access(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostOauth2AccessRequest body: Amber account credentials (required)
        :return: PostOauth2AccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_oauth2_access_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_oauth2_access_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_oauth2_access_with_http_info(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;request an API token given license and secret key  # noqa: E501

        Request an Oauth2 Bearer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_oauth2_access_with_http_info(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostOauth2AccessRequest body: Amber account credentials (required)
        :return: PostOauth2AccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_oauth2_access&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_oauth2_access`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            &#39;/oauth2/access&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostOauth2AccessResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def post_oauth2_refresh(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;request an API token given a refresh token  # noqa: E501

        Request an Oauth2 Bearer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_oauth2_refresh(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostOauth2RefreshRequest body: Amber account credentials (required)
        :return: PostOauth2RefreshResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.post_oauth2_refresh_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_oauth2_refresh_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_oauth2_refresh_with_http_info(self, body, **kwargs):  # noqa: E501
        &#34;&#34;&#34;request an API token given a refresh token  # noqa: E501

        Request an Oauth2 Bearer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.post_oauth2_refresh_with_http_info(body, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PostOauth2RefreshRequest body: Amber account credentials (required)
        :return: PostOauth2RefreshResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method post_oauth2_refresh&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `post_oauth2_refresh`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            &#39;/oauth2/refresh&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostOauth2RefreshResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def put_model(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update model metadata  # noqa: E501

        Update metadata for the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.put_model(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PutModelRequest body: updates to apply (required)
        :param str model_id: (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.put_model_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_model_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def put_model_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update model metadata  # noqa: E501

        Update metadata for the specified model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.put_model_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PutModelRequest body: updates to apply (required)
        :param str model_id: (required)
        :return: PostModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method put_model&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `put_model`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `put_model`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}&#39;, &#39;PUT&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PostModelResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def put_model_data(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update fusion vector and get back results  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.put_model_data(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PutDataRequest body: updates to the fusion vector (required)
        :param str model_id: (required)
        :return: PutDataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        if kwargs.get(&#39;async_req&#39;):
            return self.put_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
            return data

    def put_model_data_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;update fusion vector and get back results  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.put_model_data_with_http_info(body, model_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool
        :param PutDataRequest body: updates to the fusion vector (required)
        :param str model_id: (required)
        :return: PutDataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
        all_params.append(&#39;async_req&#39;)
        all_params.append(&#39;_return_http_data_only&#39;)
        all_params.append(&#39;_preload_content&#39;)
        all_params.append(&#39;_request_timeout&#39;)

        params = locals()
        for key, val in six.iteritems(params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise TypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method put_model_data&#34; % key
                )
            params[key] = val
        del params[&#39;kwargs&#39;]
        # verify the required parameter &#39;body&#39; is set
        if (&#39;body&#39; not in params or
                params[&#39;body&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `body` when calling `put_model_data`&#34;)  # noqa: E501
        # verify the required parameter &#39;model_id&#39; is set
        if (&#39;model_id&#39; not in params or
                params[&#39;model_id&#39;] is None):
            raise ValueError(&#34;Missing the required parameter `model_id` when calling `put_model_data`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;model_id&#39; in params:
            path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;body&#39; in params:
            body_params = params[&#39;body&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;Bearer&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/models/{modelId}/data&#39;, &#39;PUT&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PutDataResponse&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get(&#39;async_req&#39;),
            _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
            _preload_content=params.get(&#39;_preload_content&#39;, True),
            _request_timeout=params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="boonamber.v2.api.default_api.DefaultApi.delete_model"><code class="name flex">
<span>def <span class="ident">delete_model</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>delete a model
# noqa: E501</p>
<p>Permanently delete the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.delete_model(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: DeleteModelResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_model(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;delete a model  # noqa: E501

    Permanently delete the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.delete_model(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: DeleteModelResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.delete_model_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.delete_model_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.delete_model_with_http_info"><code class="name flex">
<span>def <span class="ident">delete_model_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>delete a model
# noqa: E501</p>
<p>Permanently delete the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.delete_model_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: DeleteModelResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_model_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;delete a model  # noqa: E501

    Permanently delete the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.delete_model_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: DeleteModelResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method delete_model&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `delete_model`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}&#39;, &#39;DELETE&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;DeleteModelResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model"><code class="name flex">
<span>def <span class="ident">get_model</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get model metadata
# noqa: E501</p>
<p>Return metadata for the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: PostModelResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get model metadata  # noqa: E501

    Return metadata for the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: PostModelResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_model_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.get_model_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_config"><code class="name flex">
<span>def <span class="ident">get_model_config</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get model configuration
# noqa: E501</p>
<p>Get the configuration of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_config(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: PostConfigResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_config(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get model configuration  # noqa: E501

    Get the configuration of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_config(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: PostConfigResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.get_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_config_with_http_info"><code class="name flex">
<span>def <span class="ident">get_model_config_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get model configuration
# noqa: E501</p>
<p>Get the configuration of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_config_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: PostConfigResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_config_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get model configuration  # noqa: E501

    Get the configuration of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_config_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: PostConfigResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_model_config&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_config`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/config&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostConfigResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_nano_status"><code class="name flex">
<span>def <span class="ident">get_model_nano_status</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get current nano status of the model
# noqa: E501</p>
<p>Get the current nano state of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_nano_status(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: GetNanoStatusResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_nano_status(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get current nano status of the model  # noqa: E501

    Get the current nano state of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_nano_status(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: GetNanoStatusResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_model_nano_status_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.get_model_nano_status_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_nano_status_with_http_info"><code class="name flex">
<span>def <span class="ident">get_model_nano_status_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get current nano status of the model
# noqa: E501</p>
<p>Get the current nano state of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_nano_status_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: GetNanoStatusResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_nano_status_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get current nano status of the model  # noqa: E501

    Get the current nano state of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_nano_status_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: GetNanoStatusResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_model_nano_status&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_nano_status`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/status/nano&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;GetNanoStatusResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_pretrain"><code class="name flex">
<span>def <span class="ident">get_model_pretrain</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get pretraining progress
# noqa: E501</p>
<p>Get the pretraining status of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_pretrain(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: GetPretrainResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_pretrain(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get pretraining progress  # noqa: E501

    Get the pretraining status of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_pretrain(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: GetPretrainResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_model_pretrain_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.get_model_pretrain_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_pretrain_with_http_info"><code class="name flex">
<span>def <span class="ident">get_model_pretrain_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get pretraining progress
# noqa: E501</p>
<p>Get the pretraining status of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_pretrain_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: GetPretrainResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_pretrain_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get pretraining progress  # noqa: E501

    Get the pretraining status of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_pretrain_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: GetPretrainResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_model_pretrain&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_pretrain`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/pretrain&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;GetPretrainResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_root_cause"><code class="name flex">
<span>def <span class="ident">get_model_root_cause</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>perform root cause analysis
# noqa: E501</p>
<p>Return a measure of the significance of each feature in the creation of a cluster. The values range from 0 to 1 where a relatively high value represents a feature that was influential in creating the new cluster. No conclusions can be drawn from values close to zero. This measure can be computed for existing clusters or for individual vectors directly.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_root_cause(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:param str clusters: Clusters to analyze (list of comma-separated integers).
:param str vectors: Vectors to analyze, as a flat list of comma-separated floats. Number of values must be a multiple of the configured number of features.
:return: GetRootCauseResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_root_cause(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;perform root cause analysis  # noqa: E501

    Return a measure of the significance of each feature in the creation of a cluster. The values range from 0 to 1 where a relatively high value represents a feature that was influential in creating the new cluster. No conclusions can be drawn from values close to zero. This measure can be computed for existing clusters or for individual vectors directly.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_root_cause(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :param str clusters: Clusters to analyze (list of comma-separated integers).
    :param str vectors: Vectors to analyze, as a flat list of comma-separated floats. Number of values must be a multiple of the configured number of features.
    :return: GetRootCauseResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_model_root_cause_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.get_model_root_cause_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_root_cause_with_http_info"><code class="name flex">
<span>def <span class="ident">get_model_root_cause_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>perform root cause analysis
# noqa: E501</p>
<p>Return a measure of the significance of each feature in the creation of a cluster. The values range from 0 to 1 where a relatively high value represents a feature that was influential in creating the new cluster. No conclusions can be drawn from values close to zero. This measure can be computed for existing clusters or for individual vectors directly.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_root_cause_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:param str clusters: Clusters to analyze (list of comma-separated integers).
:param str vectors: Vectors to analyze, as a flat list of comma-separated floats. Number of values must be a multiple of the configured number of features.
:return: GetRootCauseResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_root_cause_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;perform root cause analysis  # noqa: E501

    Return a measure of the significance of each feature in the creation of a cluster. The values range from 0 to 1 where a relatively high value represents a feature that was influential in creating the new cluster. No conclusions can be drawn from values close to zero. This measure can be computed for existing clusters or for individual vectors directly.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_root_cause_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :param str clusters: Clusters to analyze (list of comma-separated integers).
    :param str vectors: Vectors to analyze, as a flat list of comma-separated floats. Number of values must be a multiple of the configured number of features.
    :return: GetRootCauseResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;, &#39;clusters&#39;, &#39;vectors&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_model_root_cause&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_root_cause`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []
    if &#39;clusters&#39; in params:
        query_params.append((&#39;clusters&#39;, params[&#39;clusters&#39;]))  # noqa: E501
    if &#39;vectors&#39; in params:
        query_params.append((&#39;vectors&#39;, params[&#39;vectors&#39;]))  # noqa: E501

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/rootCause&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;GetRootCauseResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_status"><code class="name flex">
<span>def <span class="ident">get_model_status</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get current status of the model
# noqa: E501</p>
<p>Get the current state and learning progress of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_status(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: GetStatusResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_status(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get current status of the model  # noqa: E501

    Get the current state and learning progress of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_status(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: GetStatusResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_model_status_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.get_model_status_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_status_with_http_info"><code class="name flex">
<span>def <span class="ident">get_model_status_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get current status of the model
# noqa: E501</p>
<p>Get the current state and learning progress of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_status_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: GetStatusResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_status_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get current status of the model  # noqa: E501

    Get the current state and learning progress of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_status_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: GetStatusResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_model_status&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_status`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/status&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;GetStatusResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_summary"><code class="name flex">
<span>def <span class="ident">get_model_summary</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get the summation of a model
# noqa: E501</p>
<p>Get the current summation of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_summary(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: GetSummaryResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_summary(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get the summation of a model  # noqa: E501

    Get the current summation of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_summary(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: GetSummaryResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_model_summary_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.get_model_summary_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_summary_with_http_info"><code class="name flex">
<span>def <span class="ident">get_model_summary_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get the summation of a model
# noqa: E501</p>
<p>Get the current summation of the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_summary_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: GetSummaryResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_summary_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get the summation of a model  # noqa: E501

    Get the current summation of the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_summary_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: GetSummaryResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_model_summary&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model_summary`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/summary&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;GetSummaryResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_model_with_http_info"><code class="name flex">
<span>def <span class="ident">get_model_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get model metadata
# noqa: E501</p>
<p>Return metadata for the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_model_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: PostModelResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get model metadata  # noqa: E501

    Return metadata for the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_model_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: PostModelResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_model&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `get_model`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostModelResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_models"><code class="name flex">
<span>def <span class="ident">get_models</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>list all models
# noqa: E501</p>
<p>Return <code>id</code> and <code>label</code> for all models belonging to the user.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_models(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str verbose: If <code>true</code>, include full model metadata.
:return: GetModelsResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_models(self, **kwargs):  # noqa: E501
    &#34;&#34;&#34;list all models  # noqa: E501

    Return `id` and `label` for all models belonging to the user.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_models(async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str verbose: If `true`, include full model metadata.
    :return: GetModelsResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_models_with_http_info(**kwargs)  # noqa: E501
    else:
        (data) = self.get_models_with_http_info(**kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_models_with_http_info"><code class="name flex">
<span>def <span class="ident">get_models_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>list all models
# noqa: E501</p>
<p>Return <code>id</code> and <code>label</code> for all models belonging to the user.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_models_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str verbose: If <code>true</code>, include full model metadata.
:return: GetModelsResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_models_with_http_info(self, **kwargs):  # noqa: E501
    &#34;&#34;&#34;list all models  # noqa: E501

    Return `id` and `label` for all models belonging to the user.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_models_with_http_info(async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str verbose: If `true`, include full model metadata.
    :return: GetModelsResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;verbose&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_models&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]

    collection_formats = {}

    path_params = {}

    query_params = []

    header_params = {}
    if &#39;verbose&#39; in params:
        header_params[&#39;verbose&#39;] = params[&#39;verbose&#39;]  # noqa: E501

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;GetModelsResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_version"><code class="name flex">
<span>def <span class="ident">get_version</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get version information
# noqa: E501</p>
<p>Return version information for the API.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_version(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:return: GetVersionResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_version(self, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get version information  # noqa: E501

    Return version information for the API.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_version(async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :return: GetVersionResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.get_version_with_http_info(**kwargs)  # noqa: E501
    else:
        (data) = self.get_version_with_http_info(**kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.get_version_with_http_info"><code class="name flex">
<span>def <span class="ident">get_version_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get version information
# noqa: E501</p>
<p>Return version information for the API.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_version_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:return: GetVersionResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_version_with_http_info(self, **kwargs):  # noqa: E501
    &#34;&#34;&#34;get version information  # noqa: E501

    Return version information for the API.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.get_version_with_http_info(async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :return: GetVersionResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = []  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method get_version&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]

    collection_formats = {}

    path_params = {}

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/version&#39;, &#39;GET&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;GetVersionResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model"><code class="name flex">
<span>def <span class="ident">post_model</span></span>(<span>self, body, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>create a model
# noqa: E501</p>
<p>Create a new model and return its unique identifier.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model(body, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostModelRequest body: initial metadata for new model (required)
:return: PostModelResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model(self, body, **kwargs):  # noqa: E501
    &#34;&#34;&#34;create a model  # noqa: E501

    Create a new model and return its unique identifier.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model(body, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostModelRequest body: initial metadata for new model (required)
    :return: PostModelResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.post_model_with_http_info(body, **kwargs)  # noqa: E501
    else:
        (data) = self.post_model_with_http_info(body, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_config"><code class="name flex">
<span>def <span class="ident">post_model_config</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>configure a model
# noqa: E501</p>
<p>Configure the specified model. Wipes all progress and puts the model in the <code>Buffering</code> state.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_config(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:param PostConfigRequest body: configuration to apply
:return: PostConfigResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_config(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;configure a model  # noqa: E501

    Configure the specified model. Wipes all progress and puts the model in the `Buffering` state.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_config(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :param PostConfigRequest body: configuration to apply
    :return: PostConfigResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.post_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.post_model_config_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_config_with_http_info"><code class="name flex">
<span>def <span class="ident">post_model_config_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>configure a model
# noqa: E501</p>
<p>Configure the specified model. Wipes all progress and puts the model in the <code>Buffering</code> state.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_config_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:param PostConfigRequest body: configuration to apply
:return: PostConfigResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_config_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;configure a model  # noqa: E501

    Configure the specified model. Wipes all progress and puts the model in the `Buffering` state.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_config_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :param PostConfigRequest body: configuration to apply
    :return: PostConfigResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;, &#39;body&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method post_model_config&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_config`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/config&#39;, &#39;POST&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostConfigResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_data"><code class="name flex">
<span>def <span class="ident">post_model_data</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>send data to model and get back results
# noqa: E501</p>
<p>Send data to the specified model, and get back the resulting analytics and model status.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_data(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostDataRequest body: data vector or vectors as a flattened list of comma-separated values (required)
:param str model_id: (required)
:return: PostDataResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_data(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;send data to model and get back results  # noqa: E501

    Send data to the specified model, and get back the resulting analytics and model status.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_data(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostDataRequest body: data vector or vectors as a flattened list of comma-separated values (required)
    :param str model_id: (required)
    :return: PostDataResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.post_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.post_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_data_with_http_info"><code class="name flex">
<span>def <span class="ident">post_model_data_with_http_info</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>send data to model and get back results
# noqa: E501</p>
<p>Send data to the specified model, and get back the resulting analytics and model status.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_data_with_http_info(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostDataRequest body: data vector or vectors as a flattened list of comma-separated values (required)
:param str model_id: (required)
:return: PostDataResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_data_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;send data to model and get back results  # noqa: E501

    Send data to the specified model, and get back the resulting analytics and model status.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_data_with_http_info(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostDataRequest body: data vector or vectors as a flattened list of comma-separated values (required)
    :param str model_id: (required)
    :return: PostDataResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method post_model_data&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;body&#39; is set
    if (&#39;body&#39; not in params or
            params[&#39;body&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_data`&#34;)  # noqa: E501
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_data`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/data&#39;, &#39;POST&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostDataResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_learning"><code class="name flex">
<span>def <span class="ident">post_model_learning</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>update model configuration and re-enable learning
# noqa: E501</p>
<p>Update model configuration and re-enable learning
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_learning(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostLearningRequest body: updates to apply (required)
:param str model_id: (required)
:return: PostLearningResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_learning(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;update model configuration and re-enable learning  # noqa: E501

    Update model configuration and re-enable learning  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_learning(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostLearningRequest body: updates to apply (required)
    :param str model_id: (required)
    :return: PostLearningResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.post_model_learning_with_http_info(body, model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.post_model_learning_with_http_info(body, model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_learning_with_http_info"><code class="name flex">
<span>def <span class="ident">post_model_learning_with_http_info</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>update model configuration and re-enable learning
# noqa: E501</p>
<p>Update model configuration and re-enable learning
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_learning_with_http_info(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostLearningRequest body: updates to apply (required)
:param str model_id: (required)
:return: PostLearningResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_learning_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;update model configuration and re-enable learning  # noqa: E501

    Update model configuration and re-enable learning  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_learning_with_http_info(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostLearningRequest body: updates to apply (required)
    :param str model_id: (required)
    :return: PostLearningResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method post_model_learning&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;body&#39; is set
    if (&#39;body&#39; not in params or
            params[&#39;body&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_learning`&#34;)  # noqa: E501
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_learning`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/learning&#39;, &#39;POST&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostLearningResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_outage"><code class="name flex">
<span>def <span class="ident">post_model_outage</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>call this after a data outage before resuming streaming
# noqa: E501</p>
<p>Resets the streaming window generated by <code>streamingWindow</code>. This endpoint should be called after a data outage before resuming streaming.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_outage(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: Error
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_outage(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;call this after a data outage before resuming streaming  # noqa: E501

    Resets the streaming window generated by `streamingWindow`. This endpoint should be called after a data outage before resuming streaming.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_outage(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: Error
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.post_model_outage_with_http_info(model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.post_model_outage_with_http_info(model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_outage_with_http_info"><code class="name flex">
<span>def <span class="ident">post_model_outage_with_http_info</span></span>(<span>self, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>call this after a data outage before resuming streaming
# noqa: E501</p>
<p>Resets the streaming window generated by <code>streamingWindow</code>. This endpoint should be called after a data outage before resuming streaming.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_outage_with_http_info(model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param str model_id: (required)
:return: Error
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_outage_with_http_info(self, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;call this after a data outage before resuming streaming  # noqa: E501

    Resets the streaming window generated by `streamingWindow`. This endpoint should be called after a data outage before resuming streaming.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_outage_with_http_info(model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param str model_id: (required)
    :return: Error
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method post_model_outage&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_outage`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/outage&#39;, &#39;POST&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;Error&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_pretrain"><code class="name flex">
<span>def <span class="ident">post_model_pretrain</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>pretrain model with an existing dataset
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_pretrain(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostPretrainRequest body: Data to use for pretraining. (required)
:param str model_id: (required)
:param str chunkspec: Chunk specifier for chunked uploads. In a chunked upload, each request is sent with a <code>chunkspec</code> of the form <code>1:3</code>, <code>2:10</code>, <code>7:7</code>, etc. where the first number is the index for the chunk being uploaded (1-based) and the second number is the total number of chunks in the transaction. The chunks may be uploaded in any order. Pretraining starts once all chunks have been received.
:param str txn_id: Transaction id for chunked uploads. The response body for the first request in a chunked upload will contain a <code>txnId</code> which uniquely identifies the chunking transaction across multiple requests. That <code>txnId</code> must be included in the header of all remaining chunks uploaded in the transaction.
:return: PostPretrainResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_pretrain(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;pretrain model with an existing dataset  # noqa: E501

    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_pretrain(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostPretrainRequest body: Data to use for pretraining. (required)
    :param str model_id: (required)
    :param str chunkspec: Chunk specifier for chunked uploads. In a chunked upload, each request is sent with a `chunkspec` of the form `1:3`, `2:10`, `7:7`, etc. where the first number is the index for the chunk being uploaded (1-based) and the second number is the total number of chunks in the transaction. The chunks may be uploaded in any order. Pretraining starts once all chunks have been received.
    :param str txn_id: Transaction id for chunked uploads. The response body for the first request in a chunked upload will contain a `txnId` which uniquely identifies the chunking transaction across multiple requests. That `txnId` must be included in the header of all remaining chunks uploaded in the transaction.
    :return: PostPretrainResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.post_model_pretrain_with_http_info(body, model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.post_model_pretrain_with_http_info(body, model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_pretrain_with_http_info"><code class="name flex">
<span>def <span class="ident">post_model_pretrain_with_http_info</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>pretrain model with an existing dataset
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_pretrain_with_http_info(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostPretrainRequest body: Data to use for pretraining. (required)
:param str model_id: (required)
:param str chunkspec: Chunk specifier for chunked uploads. In a chunked upload, each request is sent with a <code>chunkspec</code> of the form <code>1:3</code>, <code>2:10</code>, <code>7:7</code>, etc. where the first number is the index for the chunk being uploaded (1-based) and the second number is the total number of chunks in the transaction. The chunks may be uploaded in any order. Pretraining starts once all chunks have been received.
:param str txn_id: Transaction id for chunked uploads. The response body for the first request in a chunked upload will contain a <code>txnId</code> which uniquely identifies the chunking transaction across multiple requests. That <code>txnId</code> must be included in the header of all remaining chunks uploaded in the transaction.
:return: PostPretrainResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_pretrain_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;pretrain model with an existing dataset  # noqa: E501

    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_pretrain_with_http_info(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostPretrainRequest body: Data to use for pretraining. (required)
    :param str model_id: (required)
    :param str chunkspec: Chunk specifier for chunked uploads. In a chunked upload, each request is sent with a `chunkspec` of the form `1:3`, `2:10`, `7:7`, etc. where the first number is the index for the chunk being uploaded (1-based) and the second number is the total number of chunks in the transaction. The chunks may be uploaded in any order. Pretraining starts once all chunks have been received.
    :param str txn_id: Transaction id for chunked uploads. The response body for the first request in a chunked upload will contain a `txnId` which uniquely identifies the chunking transaction across multiple requests. That `txnId` must be included in the header of all remaining chunks uploaded in the transaction.
    :return: PostPretrainResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;body&#39;, &#39;model_id&#39;, &#39;chunkspec&#39;, &#39;txn_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method post_model_pretrain&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;body&#39; is set
    if (&#39;body&#39; not in params or
            params[&#39;body&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `body` when calling `post_model_pretrain`&#34;)  # noqa: E501
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `post_model_pretrain`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}
    if &#39;chunkspec&#39; in params:
        header_params[&#39;chunkspec&#39;] = params[&#39;chunkspec&#39;]  # noqa: E501
    if &#39;txn_id&#39; in params:
        header_params[&#39;txnId&#39;] = params[&#39;txn_id&#39;]  # noqa: E501

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/pretrain&#39;, &#39;POST&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostPretrainResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_model_with_http_info"><code class="name flex">
<span>def <span class="ident">post_model_with_http_info</span></span>(<span>self, body, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>create a model
# noqa: E501</p>
<p>Create a new model and return its unique identifier.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_model_with_http_info(body, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostModelRequest body: initial metadata for new model (required)
:return: PostModelResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_model_with_http_info(self, body, **kwargs):  # noqa: E501
    &#34;&#34;&#34;create a model  # noqa: E501

    Create a new model and return its unique identifier.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_model_with_http_info(body, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostModelRequest body: initial metadata for new model (required)
    :return: PostModelResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;body&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method post_model&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;body&#39; is set
    if (&#39;body&#39; not in params or
            params[&#39;body&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `body` when calling `post_model`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models&#39;, &#39;POST&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostModelResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_oauth2_access"><code class="name flex">
<span>def <span class="ident">post_oauth2_access</span></span>(<span>self, body, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>request an API token given license and secret key
# noqa: E501</p>
<p>Request an Oauth2 Bearer token.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_oauth2_access(body, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostOauth2AccessRequest body: Amber account credentials (required)
:return: PostOauth2AccessResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_oauth2_access(self, body, **kwargs):  # noqa: E501
    &#34;&#34;&#34;request an API token given license and secret key  # noqa: E501

    Request an Oauth2 Bearer token.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_oauth2_access(body, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostOauth2AccessRequest body: Amber account credentials (required)
    :return: PostOauth2AccessResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.post_oauth2_access_with_http_info(body, **kwargs)  # noqa: E501
    else:
        (data) = self.post_oauth2_access_with_http_info(body, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_oauth2_access_with_http_info"><code class="name flex">
<span>def <span class="ident">post_oauth2_access_with_http_info</span></span>(<span>self, body, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>request an API token given license and secret key
# noqa: E501</p>
<p>Request an Oauth2 Bearer token.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_oauth2_access_with_http_info(body, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostOauth2AccessRequest body: Amber account credentials (required)
:return: PostOauth2AccessResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_oauth2_access_with_http_info(self, body, **kwargs):  # noqa: E501
    &#34;&#34;&#34;request an API token given license and secret key  # noqa: E501

    Request an Oauth2 Bearer token.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_oauth2_access_with_http_info(body, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostOauth2AccessRequest body: Amber account credentials (required)
    :return: PostOauth2AccessResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;body&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method post_oauth2_access&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;body&#39; is set
    if (&#39;body&#39; not in params or
            params[&#39;body&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `body` when calling `post_oauth2_access`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = []  # noqa: E501

    return self.api_client.call_api(
        &#39;/oauth2/access&#39;, &#39;POST&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostOauth2AccessResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_oauth2_refresh"><code class="name flex">
<span>def <span class="ident">post_oauth2_refresh</span></span>(<span>self, body, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>request an API token given a refresh token
# noqa: E501</p>
<p>Request an Oauth2 Bearer token.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_oauth2_refresh(body, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostOauth2RefreshRequest body: Amber account credentials (required)
:return: PostOauth2RefreshResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_oauth2_refresh(self, body, **kwargs):  # noqa: E501
    &#34;&#34;&#34;request an API token given a refresh token  # noqa: E501

    Request an Oauth2 Bearer token.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_oauth2_refresh(body, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostOauth2RefreshRequest body: Amber account credentials (required)
    :return: PostOauth2RefreshResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.post_oauth2_refresh_with_http_info(body, **kwargs)  # noqa: E501
    else:
        (data) = self.post_oauth2_refresh_with_http_info(body, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.post_oauth2_refresh_with_http_info"><code class="name flex">
<span>def <span class="ident">post_oauth2_refresh_with_http_info</span></span>(<span>self, body, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>request an API token given a refresh token
# noqa: E501</p>
<p>Request an Oauth2 Bearer token.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.post_oauth2_refresh_with_http_info(body, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PostOauth2RefreshRequest body: Amber account credentials (required)
:return: PostOauth2RefreshResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_oauth2_refresh_with_http_info(self, body, **kwargs):  # noqa: E501
    &#34;&#34;&#34;request an API token given a refresh token  # noqa: E501

    Request an Oauth2 Bearer token.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.post_oauth2_refresh_with_http_info(body, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PostOauth2RefreshRequest body: Amber account credentials (required)
    :return: PostOauth2RefreshResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;body&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method post_oauth2_refresh&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;body&#39; is set
    if (&#39;body&#39; not in params or
            params[&#39;body&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `body` when calling `post_oauth2_refresh`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = []  # noqa: E501

    return self.api_client.call_api(
        &#39;/oauth2/refresh&#39;, &#39;POST&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostOauth2RefreshResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.put_model"><code class="name flex">
<span>def <span class="ident">put_model</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>update model metadata
# noqa: E501</p>
<p>Update metadata for the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.put_model(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PutModelRequest body: updates to apply (required)
:param str model_id: (required)
:return: PostModelResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_model(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;update model metadata  # noqa: E501

    Update metadata for the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.put_model(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PutModelRequest body: updates to apply (required)
    :param str model_id: (required)
    :return: PostModelResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.put_model_with_http_info(body, model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.put_model_with_http_info(body, model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.put_model_data"><code class="name flex">
<span>def <span class="ident">put_model_data</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>update fusion vector and get back results
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.put_model_data(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PutDataRequest body: updates to the fusion vector (required)
:param str model_id: (required)
:return: PutDataResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_model_data(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;update fusion vector and get back results  # noqa: E501

    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.put_model_data(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PutDataRequest body: updates to the fusion vector (required)
    :param str model_id: (required)
    :return: PutDataResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;
    kwargs[&#39;_return_http_data_only&#39;] = True
    if kwargs.get(&#39;async_req&#39;):
        return self.put_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
    else:
        (data) = self.put_model_data_with_http_info(body, model_id, **kwargs)  # noqa: E501
        return data</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.put_model_data_with_http_info"><code class="name flex">
<span>def <span class="ident">put_model_data_with_http_info</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>update fusion vector and get back results
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.put_model_data_with_http_info(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PutDataRequest body: updates to the fusion vector (required)
:param str model_id: (required)
:return: PutDataResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_model_data_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;update fusion vector and get back results  # noqa: E501

    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.put_model_data_with_http_info(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PutDataRequest body: updates to the fusion vector (required)
    :param str model_id: (required)
    :return: PutDataResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method put_model_data&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;body&#39; is set
    if (&#39;body&#39; not in params or
            params[&#39;body&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `body` when calling `put_model_data`&#34;)  # noqa: E501
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `put_model_data`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}/data&#39;, &#39;PUT&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PutDataResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
<dt id="boonamber.v2.api.default_api.DefaultApi.put_model_with_http_info"><code class="name flex">
<span>def <span class="ident">put_model_with_http_info</span></span>(<span>self, body, model_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>update model metadata
# noqa: E501</p>
<p>Update metadata for the specified model.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.put_model_with_http_info(body, model_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool
:param PutModelRequest body: updates to apply (required)
:param str model_id: (required)
:return: PostModelResponse
If the method is called asynchronously,
returns the request thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_model_with_http_info(self, body, model_id, **kwargs):  # noqa: E501
    &#34;&#34;&#34;update model metadata  # noqa: E501

    Update metadata for the specified model.  # noqa: E501
    This method makes a synchronous HTTP request by default. To make an
    asynchronous HTTP request, please pass async_req=True
    &gt;&gt;&gt; thread = api.put_model_with_http_info(body, model_id, async_req=True)
    &gt;&gt;&gt; result = thread.get()

    :param async_req bool
    :param PutModelRequest body: updates to apply (required)
    :param str model_id: (required)
    :return: PostModelResponse
             If the method is called asynchronously,
             returns the request thread.
    &#34;&#34;&#34;

    all_params = [&#39;body&#39;, &#39;model_id&#39;]  # noqa: E501
    all_params.append(&#39;async_req&#39;)
    all_params.append(&#39;_return_http_data_only&#39;)
    all_params.append(&#39;_preload_content&#39;)
    all_params.append(&#39;_request_timeout&#39;)

    params = locals()
    for key, val in six.iteritems(params[&#39;kwargs&#39;]):
        if key not in all_params:
            raise TypeError(
                &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                &#34; to method put_model&#34; % key
            )
        params[key] = val
    del params[&#39;kwargs&#39;]
    # verify the required parameter &#39;body&#39; is set
    if (&#39;body&#39; not in params or
            params[&#39;body&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `body` when calling `put_model`&#34;)  # noqa: E501
    # verify the required parameter &#39;model_id&#39; is set
    if (&#39;model_id&#39; not in params or
            params[&#39;model_id&#39;] is None):
        raise ValueError(&#34;Missing the required parameter `model_id` when calling `put_model`&#34;)  # noqa: E501

    collection_formats = {}

    path_params = {}
    if &#39;model_id&#39; in params:
        path_params[&#39;modelId&#39;] = params[&#39;model_id&#39;]  # noqa: E501

    query_params = []

    header_params = {}

    form_params = []
    local_var_files = {}

    body_params = None
    if &#39;body&#39; in params:
        body_params = params[&#39;body&#39;]
    # HTTP header `Accept`
    header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
        [&#39;*/*&#39;])  # noqa: E501

    # HTTP header `Content-Type`
    header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
        [&#39;application/json&#39;])  # noqa: E501

    # Authentication setting
    auth_settings = [&#39;Bearer&#39;]  # noqa: E501

    return self.api_client.call_api(
        &#39;/models/{modelId}&#39;, &#39;PUT&#39;,
        path_params,
        query_params,
        header_params,
        body=body_params,
        post_params=form_params,
        files=local_var_files,
        response_type=&#39;PostModelResponse&#39;,  # noqa: E501
        auth_settings=auth_settings,
        async_req=params.get(&#39;async_req&#39;),
        _return_http_data_only=params.get(&#39;_return_http_data_only&#39;),
        _preload_content=params.get(&#39;_preload_content&#39;, True),
        _request_timeout=params.get(&#39;_request_timeout&#39;),
        collection_formats=collection_formats)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="boonamber.v2.api" href="index.html">boonamber.v2.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="boonamber.v2.api.default_api.DefaultApi" href="#boonamber.v2.api.default_api.DefaultApi">DefaultApi</a></code></h4>
<ul class="">
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.delete_model" href="#boonamber.v2.api.default_api.DefaultApi.delete_model">delete_model</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.delete_model_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.delete_model_with_http_info">delete_model_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model" href="#boonamber.v2.api.default_api.DefaultApi.get_model">get_model</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_config" href="#boonamber.v2.api.default_api.DefaultApi.get_model_config">get_model_config</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_config_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_model_config_with_http_info">get_model_config_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_nano_status" href="#boonamber.v2.api.default_api.DefaultApi.get_model_nano_status">get_model_nano_status</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_nano_status_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_model_nano_status_with_http_info">get_model_nano_status_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_pretrain" href="#boonamber.v2.api.default_api.DefaultApi.get_model_pretrain">get_model_pretrain</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_pretrain_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_model_pretrain_with_http_info">get_model_pretrain_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_root_cause" href="#boonamber.v2.api.default_api.DefaultApi.get_model_root_cause">get_model_root_cause</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_root_cause_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_model_root_cause_with_http_info">get_model_root_cause_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_status" href="#boonamber.v2.api.default_api.DefaultApi.get_model_status">get_model_status</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_status_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_model_status_with_http_info">get_model_status_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_summary" href="#boonamber.v2.api.default_api.DefaultApi.get_model_summary">get_model_summary</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_summary_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_model_summary_with_http_info">get_model_summary_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_model_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_model_with_http_info">get_model_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_models" href="#boonamber.v2.api.default_api.DefaultApi.get_models">get_models</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_models_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_models_with_http_info">get_models_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_version" href="#boonamber.v2.api.default_api.DefaultApi.get_version">get_version</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.get_version_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.get_version_with_http_info">get_version_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model" href="#boonamber.v2.api.default_api.DefaultApi.post_model">post_model</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_config" href="#boonamber.v2.api.default_api.DefaultApi.post_model_config">post_model_config</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_config_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.post_model_config_with_http_info">post_model_config_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_data" href="#boonamber.v2.api.default_api.DefaultApi.post_model_data">post_model_data</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_data_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.post_model_data_with_http_info">post_model_data_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_learning" href="#boonamber.v2.api.default_api.DefaultApi.post_model_learning">post_model_learning</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_learning_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.post_model_learning_with_http_info">post_model_learning_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_outage" href="#boonamber.v2.api.default_api.DefaultApi.post_model_outage">post_model_outage</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_outage_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.post_model_outage_with_http_info">post_model_outage_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_pretrain" href="#boonamber.v2.api.default_api.DefaultApi.post_model_pretrain">post_model_pretrain</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_pretrain_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.post_model_pretrain_with_http_info">post_model_pretrain_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_model_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.post_model_with_http_info">post_model_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_oauth2_access" href="#boonamber.v2.api.default_api.DefaultApi.post_oauth2_access">post_oauth2_access</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_oauth2_access_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.post_oauth2_access_with_http_info">post_oauth2_access_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_oauth2_refresh" href="#boonamber.v2.api.default_api.DefaultApi.post_oauth2_refresh">post_oauth2_refresh</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.post_oauth2_refresh_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.post_oauth2_refresh_with_http_info">post_oauth2_refresh_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.put_model" href="#boonamber.v2.api.default_api.DefaultApi.put_model">put_model</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.put_model_data" href="#boonamber.v2.api.default_api.DefaultApi.put_model_data">put_model_data</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.put_model_data_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.put_model_data_with_http_info">put_model_data_with_http_info</a></code></li>
<li><code><a title="boonamber.v2.api.default_api.DefaultApi.put_model_with_http_info" href="#boonamber.v2.api.default_api.DefaultApi.put_model_with_http_info">put_model_with_http_info</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>