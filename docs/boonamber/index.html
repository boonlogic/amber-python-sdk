<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>boonamber API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>boonamber</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
import numpy as np
import json
import os
import requests
import time
import requests
from collections.abc import Iterable
from numbers import Number, Integral
from urllib3.exceptions import InsecureRequestWarning


############################
# Boon Amber Python SDK v1 #
############################


class AmberUserError(Exception):
    &#34;&#34;&#34;Raised to indicate an error in SDK usage&#34;&#34;&#34;

    def __init__(self, message):
        self.message = message


class AmberCloudError(Exception):
    &#34;&#34;&#34;Raised upon any non-200 response from the Amber cloud&#34;&#34;&#34;

    def __init__(self, code, message):
        self.code = code
        self.message = message
        super().__init__(&#34;{}: {}&#34;.format(code, message))


class AmberClient:

    def __init__(self, license_id=&#39;default&#39;, license_file=&#34;~/.Amber.license&#34;, verify=True, cert=None):
        &#34;&#34;&#34;Main client which interfaces with the Amber cloud. Amber account
        credentials are discovered within a .Amber.license file located in the
        home directory, or optionally overridden using environment variables.

        Args:
            license_id (str): license identifier label found within .Amber.license file
            license_file (str): path to .Amber.license file
            verify:  Boolean, controls whether we verify the server’s TLS certificate
            cert (bool): if String, path to ssl client cert file (.pem). If Tuple, (‘cert’, ‘key’) pair.

        Environment:

            `AMBER_LICENSE_FILE`: sets license_file path

            `AMBER_LICENSE_ID`: sets license_id

            `AMBER_USERNAME`: overrides the username as found in .Amber.license file

            `AMBER_PASSWORD`: overrides the password as found in .Amber.license file

            `AMBER_SERVER`: overrides the server as found in .Amber.license file

            `AMBER_OAUTH_SERVER`: overrides the oauth server as found in .Amber.license file

            `AMBER_SSL_CERT`: path to ssl client cert file (.pem)

            `AMBER_SSL_VERIFY`: Either a boolean, in which case it controls whether we verify the server’s TLS certificate, or a string, in which case it must be a path to a CA bundle to use

        Raises:
            AmberUserError: if error supplying authentication credentials
        &#34;&#34;&#34;

        self.token = None
        self.reauth_time = time.time()
        self.user_agent = &#39;Boon Logic / amber-python-sdk / requests&#39;

        # first load from license file, override from environment if specified
        self.license_file = license_file
        self.license_file = os.environ.get(&#39;AMBER_LICENSE_FILE&#39;, self.license_file)

        # determine which license_id to use, override from environment if specified
        self.license_id = license_id
        self.license_id = os.environ.get(&#39;AMBER_LICENSE_ID&#39;, self.license_id)

        # create license profile
        if self.license_file is not None:
            license_path = os.path.expanduser(self.license_file)
            if not os.path.exists(license_path):
                raise AmberUserError(&#34;license file {} does not exist&#34;.format(license_path))
            try:
                with open(license_path, &#39;r&#39;) as f:
                    file_data = json.load(f)
            except json.JSONDecodeError as e:
                raise AmberUserError(
                    &#34;JSON formatting error in license file: {}, line: {}, col: {}&#34;.format(e.msg, e.lineno, e.colno))
            try:
                self.license_profile = file_data[self.license_id]
            except KeyError:
                raise AmberUserError(&#34;license_id \&#34;{}\&#34; not found in license file&#34;.format(self.license_id))
        else:
            # no license file found, create a stub profile to be filled in from environment
            self.license_profile = json.loads(&#39;{&#34;username&#34;: &#34;&#34;, &#34;password&#34;: &#34;&#34;, &#34;server&#34;: &#34;&#34;, &#34;oauth-server&#34;: &#34;&#34;}&#39;)

        # override from environment if specified
        try:
            self.license_profile[&#39;username&#39;] = os.environ.get(&#39;AMBER_USERNAME&#39;, self.license_profile[&#39;username&#39;])
            self.license_profile[&#39;password&#39;] = os.environ.get(&#39;AMBER_PASSWORD&#39;, self.license_profile[&#39;password&#39;])
            self.license_profile[&#39;server&#39;] = os.environ.get(&#39;AMBER_SERVER&#39;, self.license_profile[&#39;server&#39;])
            self.license_profile[&#39;oauth-server&#39;] = os.environ.get(&#39;AMBER_OAUTH_SERVER&#39;, self.license_profile[&#39;server&#39;])
            self.license_profile[&#39;cert&#39;] = os.environ.get(&#39;AMBER_SSL_CERT&#39;, cert)
            verify_str = os.environ.get(&#39;AMBER_SSL_VERIFY&#39;, &#34;true&#34;).lower()
            self.license_profile[&#39;verify&#39;] = True  # Default
            if not verify or verify_str == &#34;false&#34;:
                self.license_profile[&#39;verify&#39;] = False
        except KeyError as e:
            raise AmberUserError(&#34;missing field&#34;)

        if self.license_profile[&#39;verify&#39;] is False:
            requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

        # verify required profile elements have been created
        if self.license_profile[&#39;username&#39;] == &#34;&#34;:
            raise AmberUserError(&#34;username \&#34;{}\&#34; not specified&#34;.format(self.license_profile[&#39;username&#39;]))
        if self.license_profile[&#39;password&#39;] == &#34;&#34;:
            raise AmberUserError(&#34;password \&#34;{}\&#34; not specified&#34;.format(self.license_profile[&#39;password&#39;]))
        if self.license_profile[&#39;server&#39;] == &#34;&#34;:
            raise AmberUserError(&#34;server \&#34;{}\&#34; not specified&#34;.format(self.license_profile[&#39;server&#39;]))

    def _authenticate(self):
        &#34;&#34;&#34;Authenticate client for the next hour using the credentials given at
        initialization. This acquires and stores an oauth2 token which remains
        valid for one hour and is used to authenticate all other API requests.

        Raises:
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;oauth-server&#39;] + &#39;/oauth2&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;User-Agent&#39;: self.user_agent
        }
        body = {
            &#39;username&#39;: self.license_profile[&#39;username&#39;],
            &#39;password&#39;: self.license_profile[&#39;password&#39;]
        }

        try:
            response = requests.request(method=&#39;POST&#39;, url=url, headers=headers, json=body,
                                        verify=self.license_profile[&#39;verify&#39;],
                                        cert=self.license_profile[&#39;cert&#39;])
        except Exception as e:
            raise AmberCloudError(401, &#39;invalid server connection&#39;)
        if response.status_code != 200:
            message = &#34;authentication failed: {}&#34;.format(response.json()[&#39;message&#39;])
            raise AmberCloudError(response.status_code, message)

        # invalid credentials return a 200 where token is an empty string
        if not response.json()[&#39;idToken&#39;]:
            raise AmberCloudError(401, &#34;authentication failed: invalid credentials&#34;)

        self.token = response.json()[&#39;idToken&#39;]

        expire_secs = int(response.json()[&#39;expiresIn&#39;])
        self.reauth_time = time.time() + expire_secs - 60

    def _api_call(self, method, url, headers, body=None):
        &#34;&#34;&#34;Make a REST call to the Amber server and handle the response&#34;&#34;&#34;

        if time.time() &gt; self.reauth_time:
            self._authenticate()

        headers[&#39;Authorization&#39;] = &#39;Bearer {}&#39;.format(self.token)
        headers[&#39;User-Agent&#39;] = self.user_agent
        response = requests.request(method=method, url=url, headers=headers, json=body,
                                    verify=self.license_profile[&#39;verify&#39;],
                                    cert=self.license_profile[&#39;cert&#39;])

        if response.status_code != 200 and response.status_code != 202:
            raise AmberCloudError(response.status_code, response.json()[&#39;message&#39;])

        if &#39;code&#39; in response.json() and response.json()[&#39;code&#39;] != response.status_code:
            # todo: if this happens, there is a bug in the amber service.
            # is returned in the message, it should agree with the header
            raise AmberCloudError(response.json()[&#39;code&#39;], response.json()[&#39;message&#39;])

        # todo: we should not see errorMessage in the response.  It indicates a misconfigured API gateway
        if &#39;errorMessage&#39; in response.json():
            raise AmberCloudError(500, response.json()[&#39;errorMessage&#39;])

        return response.json()

    def get_version(self):
        &#34;&#34;&#34;Get version information for Amber

        Returns:
            json version information

        Raises:
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/version&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        response = self._api_call(&#39;GET&#39;, url, headers)

        return response

    def create_sensor(self, label=&#39;&#39;):
        &#34;&#34;&#34;Create a new sensor instance

        Args:
            label (str): label to assign to created sensor

        Returns:
            A string containing the `sensor_id` that was created

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        body = {
            &#39;label&#39;: label
        }
        response = self._api_call(&#39;POST&#39;, url, headers, body=body)
        sensor_id = response[&#39;sensorId&#39;]

        return sensor_id

    def update_label(self, sensor_id, label):
        &#34;&#34;&#34;Update the label of a sensor instance

        Args:
            sensor_id (str): sensor identifier
            label (str): new label to assign to sensor

        Returns:
            A string containing the new label assigned to sensor

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;label&#39;: label
        }
        response = self._api_call(&#39;PUT&#39;, url, headers, body=body)
        label = response[&#39;label&#39;]

        return label

    def delete_sensor(self, sensor_id):
        &#34;&#34;&#34;Delete an amber sensor instance

        Args:
            sensor_id (str): sensor identifier

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        response = self._api_call(&#39;DELETE&#39;, url, headers)

    def list_sensors(self):
        &#34;&#34;&#34;List all sensor instances currently associated with Amber account

        Returns:
            A dictionary mapping sensor IDs to corresponding labels

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensors&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        response = self._api_call(&#39;GET&#39;, url, headers)
        sensors = {s[&#39;sensorId&#39;]: s.get(&#39;label&#39;, None) for s in response}

        return sensors

    def configure_sensor(self, sensor_id, feature_count=1, streaming_window_size=25,
                         samples_to_buffer=10000,
                         anomaly_history_window=10000,
                         learning_rate_numerator=10,
                         learning_rate_denominator=10000,
                         learning_max_clusters=1000,
                         learning_max_samples=1000000):
        &#34;&#34;&#34;Configure an amber sensor instance

        Args:
            sensor_id (str): sensor identifier
            feature_count (int): number of features (dimensionality of each data sample)
            streaming_window_size (int): streaming window size (number of samples)
            samples_to_buffer (int): number of samples to load before autotuning
            anomaly_history_window (int): number of samples to use for AH calculation
            learning_rate_numerator (int): sensor &#34;graduates&#34; (i.e. transitions from
                learning to monitoring mode) if fewer than learning_rate_numerator
                new clusters are opened in the last learning_rate_denominator samples
            learning_rate_denominator (int): see learning_rate_numerator
            learning_max_clusters (int): sensor graduates if this many clusters are created
            learning_max_samples (int): sensor graduates if this many samples are processed

        Returns:
            A dictionary containing:

                {
                    &#39;feature_count&#39;: int,
                    &#39;streaming_window_size&#39;: int,
                    &#39;samples_to_buffer&#39;: int
                    &#39;anomaly_history_window&#39;: int,
                    &#39;learning_rate_numerator&#39;: int,
                    &#39;learning_rate_denominator&#39;: int,
                    &#39;learning_max_clusters&#39;: int,
                    &#39;learning_max_samples&#39;: int
                }

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid options
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;
        if not feature_count &gt; 0 or not isinstance(feature_count, Integral):
            raise AmberUserError(&#34;invalid &#39;feature_count&#39;: must be positive integer&#34;)

        if not streaming_window_size &gt; 0 or not isinstance(streaming_window_size, Integral):
            raise AmberUserError(&#34;invalid &#39;streaming_window_size&#39;: must be positive integer&#34;)

        url = self.license_profile[&#39;server&#39;] + &#39;/config&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;featureCount&#39;: feature_count,
            &#39;streamingWindowSize&#39;: streaming_window_size,
            &#39;samplesToBuffer&#39;: samples_to_buffer,
            &#39;anomalyHistoryWindow&#39;: anomaly_history_window,
            &#39;learningRateNumerator&#39;: learning_rate_numerator,
            &#39;learningRateDenominator&#39;: learning_rate_denominator,
            &#39;learningMaxClusters&#39;: learning_max_clusters,
            &#39;learningMaxSamples&#39;: learning_max_samples
        }
        config = self._api_call(&#39;POST&#39;, url, headers, body=body)

        return config

    def _isiterable(self, x):
        # consider strings non-iterable for shape validation purposes,
        # that way they are printed out whole when caught as nonnumeric
        if isinstance(x, str):
            return False

        # collections.abc docs: &#34;The only reliable way to determine
        # whether an object is iterable is to call iter(obj).&#34;
        try:
            iter(x)
        except TypeError:
            return False

        return True

    def _validate_dims(self, data):
        &#34;&#34;&#34;Validate that data is non-empty and one of the following:
           scalar value, list-like or list-of-lists-like where all
           sublists have equal length. Return 0, 1 or 2 as inferred
           number of array dimensions
        &#34;&#34;&#34;

        # not-iterable data is a single scalar data point
        if not self._isiterable(data):
            return 0

        # iterable and unnested data is a 1-d array
        if not any(self._isiterable(d) for d in data):
            if len(list(data)) == 0:
                raise ValueError(&#34;empty&#34;)

            return 1

        # iterable and nested data is 2-d array
        if not all(self._isiterable(d) for d in data):
            raise ValueError(&#34;cannot mix nested scalars and iterables&#34;)

        sublengths = [len(list(d)) for d in data]
        if len(set(sublengths)) &gt; 1:
            raise ValueError(&#34;nested sublists must have equal length&#34;)

        flattened_2d = list(itertools.chain.from_iterable(data))

        if any(isinstance(i, Iterable) for i in flattened_2d):
            raise ValueError(&#34;cannot be nested deeper than list-of-lists&#34;)

        if sublengths[0] == 0:
            raise ValueError(&#34;empty&#34;)

        return 2

    def _convert_to_csv(self, data):
        &#34;&#34;&#34;Validate data and convert to a comma-separated plaintext string&#34;&#34;&#34;

        # Note: as in the Boon Nano SDK, there is no check that data dimensions
        # align with number of features and streaming window size.
        ndim = self._validate_dims(data)

        if ndim == 0:
            data_flat = [data]
        elif ndim == 1:
            data_flat = list(data)
        elif ndim == 2:
            data_flat = list(itertools.chain.from_iterable(data))

        for d in data_flat:
            if not isinstance(d, Number):
                raise ValueError(&#34;contained {} which is not numeric&#34;.format(d.__repr__()))

        return &#39;,&#39;.join([str(float(d)) for d in data_flat])

    def pretrain_sensor(self, sensor_id, data, autotune_config=True, block=True):
        &#34;&#34;&#34;Pretrain a sensor with historical data

        Args:
            sensor_id (str): sensor identifier
            data (array-like): data to be inferenced. Must be non-empty,
                entirely numeric and one of the following: scalar value,
                list-like or list-of-lists-like where all sublists have
                equal length.
            autotune_config (bool): if True, the sensor will be reconfigured based
                on the training data provided so that the sensor will be in monitoring
                once the data is through. If False, the sensor uses the already
                configured values to train the sensor.
            block (bool): if True, will block until pretraining is complete.
                Otherwise, will return immediately; in this case pretraining
                status can be checked using get_pretrain_state endpoint.

        Returns:

            {
                &#39;state&#39;: str
            }

            &#39;state&#39;: current state of the sensor.
                &#34;Pretraining&#34;: pretraining is in progress

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid data
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        # Server expects data as a plaintext string of comma-separated values.
        try:
            data_csv = self._convert_to_csv(data)
        except ValueError as e:
            raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

        url = self.license_profile[&#39;server&#39;] + &#39;/pretrain&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;data&#39;: data_csv,
            &#39;autotuneConfig&#39;: autotune_config
        }

        results = self._api_call(&#39;POST&#39;, url, headers, body=body)

        if not block:
            return results

        while True:
            results = self.get_pretrain_state(sensor_id)
            if results[&#39;state&#39;] == &#34;Pretraining&#34;:
                time.sleep(5)
                continue
            else:
                return results

    def get_pretrain_state(self, sensor_id):
        &#34;&#34;&#34;Gets the state of sensor that is being pretrained

        Args:
            sensor_id (str): sensor identifier

        Returns:

            {
                    &#39;state&#39;: str
            }

            &#39;state&#39;: current state of the sensor. One of:
                &#34;Pretraining&#34;: pretraining is in progress
                &#34;Pretrained&#34;: pretraining has completed
                &#34;Error&#34;: error has occurred
        Raises:
            AmberUserError: if client is not authenticated or supplies invalid data
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/pretrain&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }

        results = self._api_call(&#39;GET&#39;, url, headers)

        return results

    def stream_sensor(self, sensor_id, data):
        &#34;&#34;&#34;Stream data to an amber sensor and return the inference result

        Args:
            sensor_id (str): sensor identifier
            data (array-like): data to be inferenced. Must be non-empty,
                entirely numeric and one of the following: scalar value,
                list-like or list-of-lists-like where all sublists have
                equal length.

        Returns:
            A dictionary containing inferencing results:

                {
                    &#39;state&#39;: str,
                    &#39;message&#39;: str,
                    &#39;progress&#39;: int,
                    &#39;clusterCount&#39;: int,
                    &#39;retryCount&#39;: int,
                    &#39;streamingWindowSize&#39;: int,
                    &#39;totalInferences&#39;: int,
                    &#39;ID&#39;: [int],
                    &#39;SI&#39;: [int],
                    &#39;AD&#39;: [int],
                    &#39;AH&#39;: [int],
                    &#39;AM&#39;: [float],
                    &#39;AW&#39;: [int]
                }

                &#39;state&#39;: current state of the sensor. One of:
                    &#34;Buffering&#34;: gathering initial sensor data
                    &#34;Autotuning&#34;: autotuning configuration in progress
                    &#34;Learning&#34;: sensor is active and learning
                    &#34;Monitoring&#34;: sensor is active but monitoring only (learning disabled)
                    &#34;Error&#34;: fatal error has occurred
                &#39;message&#39;: accompanying message for current sensor state
                &#39;progress&#39; progress as a percentage value (applicable for &#34;Buffering&#34; and &#34;Autotuning&#34; states)
                &#39;clusterCount&#39; number of clusters created so far
                &#39;retryCount&#39; number of times autotuning was re-attempted to tune streamingWindowSize
                &#39;streamingWindowSize&#39;: streaming window size of sensor (may differ from value
                    given at configuration if window size was adjusted during autotune)
                &#39;totalInferences&#39;: number of inferences since configuration
                &#39;ID&#39;: list of cluster IDs. The values in this list correspond one-to-one
                    with input samples, indicating the cluster to which each input pattern
                    was assigned.
                &#39;SI&#39;: smoothed anomaly index. The values in this list correspond
                    one-for-one with input samples and range between 0 and 1000. Values
                    closer to 0 represent input patterns which are ordinary given the data
                    seen so far on this sensor. Values closer to 1000 represent novel patterns
                    which are anomalous with respect to data seen before.
                &#39;RI&#39;: raw anomaly index. These values are the SI values without any smoothing.
                &#39;AD&#39;: list of binary anomaly detection values. These correspond one-to-one
                    with input samples and are produced by thresholding the smoothed anomaly
                    index (SI). The threshold is determined automatically from the SI values.
                    A value of 0 indicates that the SI has not exceeded the anomaly detection
                    threshold. A value of 1 indicates it has, signaling an anomaly at the
                    corresponding input sample.
                &#39;AH&#39;: list of anomaly history values. These values are a moving-window sum of
                    the AD value, giving the number of anomaly detections (1&#39;s) present in the
                    AD signal over a &#34;recent history&#34; window whose length is the buffer size.
                &#39;AM&#39;: list of &#34;Amber Metric&#34; values. These are floating point values between
                    0.0 and 1.0 indicating the extent to which each corresponding AH value
                    shows an unusually high number of anomalies in recent history. The values
                    are derived statistically from a Poisson model, with values close to 0.0
                    signaling a lower, and values close to 1.0 signaling a higher, frequency
                    of anomalies than usual.
                &#39;AW&#39;: list of &#34;Amber Warning Level&#34; values. This index is produced by thresholding
                    the Amber Metric (AM) and takes on the values 0, 1 or 2 representing a discrete
                    &#34;warning level&#34; for an asset based on the frequency of anomalies within recent
                    history. 0 = normal, 1 = asset changing, 2 = asset critical. The default
                    thresholds for the two warning levels are the standard statistical values
                    of 0.95 (outlier, asset changing) and 0.997 (extreme outlier, asset critical).

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid data
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        # Server expects data as a plaintext string of comma-separated values.
        try:
            data_csv = self._convert_to_csv(data)
        except ValueError as e:
            raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

        url = self.license_profile[&#39;server&#39;] + &#39;/stream&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;data&#39;: data_csv
        }

        results = self._api_call(&#39;POST&#39;, url, headers, body=body)

        return results

    def get_sensor(self, sensor_id):
        &#34;&#34;&#34;Get info about a sensor

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing sensor information:

                {
                    &#39;label&#39;: str,
                    &#39;sensorId&#39;: str,
                    &#39;usageInfo&#39;: {
                        putSensor {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        getSensor {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        getConfig {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        postStream {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: int
                            &#39;samplesTotal&#39;: int
                            &#39;samplesThisPeriod&#39;: int
                        }
                        getStatus {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        }
                    }
                }

                &#39;label&#39; (str): sensor label
                &#39;sensorId&#39; (str): sensor identifier
                &#39;callsTotal&#39;: total number of calls to this endpoint
                &#39;callsThisPeriod&#39;: calls this billing period to this endpoint
                &#39;lastCalled&#39;: ISO formatted time of last call to this endpoint
                &#39;samplesTotal&#39;: total number of samples processed
                &#39;samplesThisPeriod&#39;: number of samples processed this billing period

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        sensor = self._api_call(&#39;GET&#39;, url, headers)

        return sensor

    def get_config(self, sensor_id):
        &#34;&#34;&#34;Get current sensor configuration

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing the current sensor configuration:

                {
                    &#39;featureCount&#39;: int,
                    &#39;streamingWindowSize&#39;: int,
                    &#39;samplesToBuffer&#39;: int,
                    &#39;anomalyHistoryWindow&#39;: int,
                    &#39;learningRateNumerator&#39;: int,
                    &#39;learningRateDenominator&#39;: int,
                    &#39;learningMaxClusters&#39;: int,
                    &#39;learningMaxSamples&#39;: int,
                    &#39;percentVariation&#39;: float,
                    &#39;features&#39;:
                    [
                        {
                            &#39;min&#39;: float,
                            &#39;max&#39;: float
                        }
                    ]
                }

                &#39;featureCount&#39;: number of features (dimensionality of each data sample)
                &#39;streamingWindowSize&#39;: streaming window size (number of samples)
                &#39;samplesToBuffer&#39;: number of samples to load before autotuning
                &#39;anomalyHistoryWindow&#39;: number of samples to calculate normal anomaly variation
                &#39;learningRateNumerator&#39;: sensor &#34;graduates&#34; (i.e. transitions from
                    learning to monitoring mode) if fewer than learning_rate_numerator
                    new clusters are opened in the last learning_rate_denominator samples
                &#39;learningRateDenominator&#39;: see learning_rate_numerator
                &#39;learningMaxClusters&#39;: sensor graduates if this many clusters are created
                &#39;learningMaxSamples&#39;: sensor graduates if this many samples are processed
                &#39;percentVariation&#39;: percent variation parameter discovered by autotuning
                &#39;features&#39;: min/max values per feature discovered by autotuning
        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/config&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        config = self._api_call(&#39;GET&#39;, url, headers)

        return config

    def get_status(self, sensor_id):
        &#34;&#34;&#34;Get sensor status

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing the clustering status for a sensor:

                {
                    &#39;pca&#39; [(int,int,int)],
                    &#39;clusterGrowth&#39; [int],
                    &#39;clusterSizes&#39; [int],
                    &#39;anomalyIndexes&#39; [int],
                    &#39;frequencyIndexes&#39; [int],
                    &#39;distanceIndexes&#39; [int],
                    &#39;totalInferences&#39; [int],
                    &#39;numClusters&#39; [int],
                }

                &#39;pca&#39;: list of length-3 vectors representing cluster centroids
                    with dimensionality reduced to 3 principal components. List length
                    is one plus the maximum cluster ID, with element 0 corresponding
                    to the &#34;zero&#34; cluster, element 1 corresponding to cluster ID 1, etc.
                &#39;clusterGrowth&#39;: sample index at which each new cluster was created.
                    Elements for this and other list results are ordered as in &#39;pca&#39;.
                &#39;clusterSizes&#39;: number of samples in each cluster
                &#39;anomalyIndexes&#39;: anomaly index associated with each cluster
                &#39;frequencyIndexes&#39;: frequency index associated with each cluster
                &#39;distanceIndexes&#39;: distance index associated with each cluster
                &#39;totalInferences&#39;: total number of inferences performed so far
                &#39;numClusters&#39;: number of clusters created so far (includes zero cluster)

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/status&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        status = self._api_call(&#39;GET&#39;, url, headers)

        return status

    def get_root_cause(self, sensor_id, id_list=[], pattern_list=[]):
        &#34;&#34;&#34;Get root cause

        Args:
            sensor_id (str): sensor identifier
            id_list (list): list of IDs to return the root cause for
            pattern_list (list): list of pattern vectors to calculate the root cause against the model

        Returns:
            A list containing the root cause for each pattern/id provided for a sensor:

                [float]

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        if len(id_list) != 0 and len(pattern_list) != 0:
            raise AmberUserError(&#39;Cannot specify both patterns and cluster IDs for analysis&#39;)
        url_call = &#39;rootCause?&#39;
        if len(id_list) != 0:
            # IDs
            id_list = [str(element) for element in id_list]
            url_call = url_call + &#39;clusterID=[&#39; + &#34;,&#34;.join(id_list) + &#39;]&#39;
        elif len(pattern_list) != 0:
            # patterns
            if len(np.array(pattern_list).shape) == 1:  # only 1 pattern provided
                pattern_list = [pattern_list]
            else:
                for i, pattern in enumerate(pattern_list):
                    pattern_list[i] = &#39;,&#39;.join([str(element) for element in pattern])
            url_call = url_call + &#39;pattern=[[&#39; + &#34;],[&#34;.join(pattern_list) + &#39;]]&#39;
        else:
            raise AmberUserError(&#39;Must specify either cluster IDs or patterns to analyze&#39;)

        url = self.license_profile[&#39;server&#39;] + &#39;/&#39; + url_call
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        status = self._api_call(&#39;GET&#39;, url, headers)

        return status</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="boonamber.AmberClient"><code class="flex name class">
<span>class <span class="ident">AmberClient</span></span>
<span>(</span><span>license_id='default', license_file='~/.Amber.license', verify=True, cert=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Main client which interfaces with the Amber cloud. Amber account
credentials are discovered within a .Amber.license file located in the
home directory, or optionally overridden using environment variables.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>license_id</code></strong> :&ensp;<code>str</code></dt>
<dd>license identifier label found within .Amber.license file</dd>
<dt><strong><code>license_file</code></strong> :&ensp;<code>str</code></dt>
<dd>path to .Amber.license file</dd>
<dt><strong><code>verify</code></strong></dt>
<dd>Boolean, controls whether we verify the server’s TLS certificate</dd>
<dt><strong><code>cert</code></strong> :&ensp;<code>bool</code></dt>
<dd>if String, path to ssl client cert file (.pem). If Tuple, (‘cert’, ‘key’) pair.</dd>
</dl>
<h2 id="environment">Environment</h2>
<p><code>AMBER_LICENSE_FILE</code>: sets license_file path</p>
<p><code>AMBER_LICENSE_ID</code>: sets license_id</p>
<p><code>AMBER_USERNAME</code>: overrides the username as found in .Amber.license file</p>
<p><code>AMBER_PASSWORD</code>: overrides the password as found in .Amber.license file</p>
<p><code>AMBER_SERVER</code>: overrides the server as found in .Amber.license file</p>
<p><code>AMBER_OAUTH_SERVER</code>: overrides the oauth server as found in .Amber.license file</p>
<p><code>AMBER_SSL_CERT</code>: path to ssl client cert file (.pem)</p>
<p><code>AMBER_SSL_VERIFY</code>: Either a boolean, in which case it controls whether we verify the server’s TLS certificate, or a string, in which case it must be a path to a CA bundle to use</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if error supplying authentication credentials</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmberClient:

    def __init__(self, license_id=&#39;default&#39;, license_file=&#34;~/.Amber.license&#34;, verify=True, cert=None):
        &#34;&#34;&#34;Main client which interfaces with the Amber cloud. Amber account
        credentials are discovered within a .Amber.license file located in the
        home directory, or optionally overridden using environment variables.

        Args:
            license_id (str): license identifier label found within .Amber.license file
            license_file (str): path to .Amber.license file
            verify:  Boolean, controls whether we verify the server’s TLS certificate
            cert (bool): if String, path to ssl client cert file (.pem). If Tuple, (‘cert’, ‘key’) pair.

        Environment:

            `AMBER_LICENSE_FILE`: sets license_file path

            `AMBER_LICENSE_ID`: sets license_id

            `AMBER_USERNAME`: overrides the username as found in .Amber.license file

            `AMBER_PASSWORD`: overrides the password as found in .Amber.license file

            `AMBER_SERVER`: overrides the server as found in .Amber.license file

            `AMBER_OAUTH_SERVER`: overrides the oauth server as found in .Amber.license file

            `AMBER_SSL_CERT`: path to ssl client cert file (.pem)

            `AMBER_SSL_VERIFY`: Either a boolean, in which case it controls whether we verify the server’s TLS certificate, or a string, in which case it must be a path to a CA bundle to use

        Raises:
            AmberUserError: if error supplying authentication credentials
        &#34;&#34;&#34;

        self.token = None
        self.reauth_time = time.time()
        self.user_agent = &#39;Boon Logic / amber-python-sdk / requests&#39;

        # first load from license file, override from environment if specified
        self.license_file = license_file
        self.license_file = os.environ.get(&#39;AMBER_LICENSE_FILE&#39;, self.license_file)

        # determine which license_id to use, override from environment if specified
        self.license_id = license_id
        self.license_id = os.environ.get(&#39;AMBER_LICENSE_ID&#39;, self.license_id)

        # create license profile
        if self.license_file is not None:
            license_path = os.path.expanduser(self.license_file)
            if not os.path.exists(license_path):
                raise AmberUserError(&#34;license file {} does not exist&#34;.format(license_path))
            try:
                with open(license_path, &#39;r&#39;) as f:
                    file_data = json.load(f)
            except json.JSONDecodeError as e:
                raise AmberUserError(
                    &#34;JSON formatting error in license file: {}, line: {}, col: {}&#34;.format(e.msg, e.lineno, e.colno))
            try:
                self.license_profile = file_data[self.license_id]
            except KeyError:
                raise AmberUserError(&#34;license_id \&#34;{}\&#34; not found in license file&#34;.format(self.license_id))
        else:
            # no license file found, create a stub profile to be filled in from environment
            self.license_profile = json.loads(&#39;{&#34;username&#34;: &#34;&#34;, &#34;password&#34;: &#34;&#34;, &#34;server&#34;: &#34;&#34;, &#34;oauth-server&#34;: &#34;&#34;}&#39;)

        # override from environment if specified
        try:
            self.license_profile[&#39;username&#39;] = os.environ.get(&#39;AMBER_USERNAME&#39;, self.license_profile[&#39;username&#39;])
            self.license_profile[&#39;password&#39;] = os.environ.get(&#39;AMBER_PASSWORD&#39;, self.license_profile[&#39;password&#39;])
            self.license_profile[&#39;server&#39;] = os.environ.get(&#39;AMBER_SERVER&#39;, self.license_profile[&#39;server&#39;])
            self.license_profile[&#39;oauth-server&#39;] = os.environ.get(&#39;AMBER_OAUTH_SERVER&#39;, self.license_profile[&#39;server&#39;])
            self.license_profile[&#39;cert&#39;] = os.environ.get(&#39;AMBER_SSL_CERT&#39;, cert)
            verify_str = os.environ.get(&#39;AMBER_SSL_VERIFY&#39;, &#34;true&#34;).lower()
            self.license_profile[&#39;verify&#39;] = True  # Default
            if not verify or verify_str == &#34;false&#34;:
                self.license_profile[&#39;verify&#39;] = False
        except KeyError as e:
            raise AmberUserError(&#34;missing field&#34;)

        if self.license_profile[&#39;verify&#39;] is False:
            requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

        # verify required profile elements have been created
        if self.license_profile[&#39;username&#39;] == &#34;&#34;:
            raise AmberUserError(&#34;username \&#34;{}\&#34; not specified&#34;.format(self.license_profile[&#39;username&#39;]))
        if self.license_profile[&#39;password&#39;] == &#34;&#34;:
            raise AmberUserError(&#34;password \&#34;{}\&#34; not specified&#34;.format(self.license_profile[&#39;password&#39;]))
        if self.license_profile[&#39;server&#39;] == &#34;&#34;:
            raise AmberUserError(&#34;server \&#34;{}\&#34; not specified&#34;.format(self.license_profile[&#39;server&#39;]))

    def _authenticate(self):
        &#34;&#34;&#34;Authenticate client for the next hour using the credentials given at
        initialization. This acquires and stores an oauth2 token which remains
        valid for one hour and is used to authenticate all other API requests.

        Raises:
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;oauth-server&#39;] + &#39;/oauth2&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;User-Agent&#39;: self.user_agent
        }
        body = {
            &#39;username&#39;: self.license_profile[&#39;username&#39;],
            &#39;password&#39;: self.license_profile[&#39;password&#39;]
        }

        try:
            response = requests.request(method=&#39;POST&#39;, url=url, headers=headers, json=body,
                                        verify=self.license_profile[&#39;verify&#39;],
                                        cert=self.license_profile[&#39;cert&#39;])
        except Exception as e:
            raise AmberCloudError(401, &#39;invalid server connection&#39;)
        if response.status_code != 200:
            message = &#34;authentication failed: {}&#34;.format(response.json()[&#39;message&#39;])
            raise AmberCloudError(response.status_code, message)

        # invalid credentials return a 200 where token is an empty string
        if not response.json()[&#39;idToken&#39;]:
            raise AmberCloudError(401, &#34;authentication failed: invalid credentials&#34;)

        self.token = response.json()[&#39;idToken&#39;]

        expire_secs = int(response.json()[&#39;expiresIn&#39;])
        self.reauth_time = time.time() + expire_secs - 60

    def _api_call(self, method, url, headers, body=None):
        &#34;&#34;&#34;Make a REST call to the Amber server and handle the response&#34;&#34;&#34;

        if time.time() &gt; self.reauth_time:
            self._authenticate()

        headers[&#39;Authorization&#39;] = &#39;Bearer {}&#39;.format(self.token)
        headers[&#39;User-Agent&#39;] = self.user_agent
        response = requests.request(method=method, url=url, headers=headers, json=body,
                                    verify=self.license_profile[&#39;verify&#39;],
                                    cert=self.license_profile[&#39;cert&#39;])

        if response.status_code != 200 and response.status_code != 202:
            raise AmberCloudError(response.status_code, response.json()[&#39;message&#39;])

        if &#39;code&#39; in response.json() and response.json()[&#39;code&#39;] != response.status_code:
            # todo: if this happens, there is a bug in the amber service.
            # is returned in the message, it should agree with the header
            raise AmberCloudError(response.json()[&#39;code&#39;], response.json()[&#39;message&#39;])

        # todo: we should not see errorMessage in the response.  It indicates a misconfigured API gateway
        if &#39;errorMessage&#39; in response.json():
            raise AmberCloudError(500, response.json()[&#39;errorMessage&#39;])

        return response.json()

    def get_version(self):
        &#34;&#34;&#34;Get version information for Amber

        Returns:
            json version information

        Raises:
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/version&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        response = self._api_call(&#39;GET&#39;, url, headers)

        return response

    def create_sensor(self, label=&#39;&#39;):
        &#34;&#34;&#34;Create a new sensor instance

        Args:
            label (str): label to assign to created sensor

        Returns:
            A string containing the `sensor_id` that was created

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        body = {
            &#39;label&#39;: label
        }
        response = self._api_call(&#39;POST&#39;, url, headers, body=body)
        sensor_id = response[&#39;sensorId&#39;]

        return sensor_id

    def update_label(self, sensor_id, label):
        &#34;&#34;&#34;Update the label of a sensor instance

        Args:
            sensor_id (str): sensor identifier
            label (str): new label to assign to sensor

        Returns:
            A string containing the new label assigned to sensor

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;label&#39;: label
        }
        response = self._api_call(&#39;PUT&#39;, url, headers, body=body)
        label = response[&#39;label&#39;]

        return label

    def delete_sensor(self, sensor_id):
        &#34;&#34;&#34;Delete an amber sensor instance

        Args:
            sensor_id (str): sensor identifier

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        response = self._api_call(&#39;DELETE&#39;, url, headers)

    def list_sensors(self):
        &#34;&#34;&#34;List all sensor instances currently associated with Amber account

        Returns:
            A dictionary mapping sensor IDs to corresponding labels

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensors&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        response = self._api_call(&#39;GET&#39;, url, headers)
        sensors = {s[&#39;sensorId&#39;]: s.get(&#39;label&#39;, None) for s in response}

        return sensors

    def configure_sensor(self, sensor_id, feature_count=1, streaming_window_size=25,
                         samples_to_buffer=10000,
                         anomaly_history_window=10000,
                         learning_rate_numerator=10,
                         learning_rate_denominator=10000,
                         learning_max_clusters=1000,
                         learning_max_samples=1000000):
        &#34;&#34;&#34;Configure an amber sensor instance

        Args:
            sensor_id (str): sensor identifier
            feature_count (int): number of features (dimensionality of each data sample)
            streaming_window_size (int): streaming window size (number of samples)
            samples_to_buffer (int): number of samples to load before autotuning
            anomaly_history_window (int): number of samples to use for AH calculation
            learning_rate_numerator (int): sensor &#34;graduates&#34; (i.e. transitions from
                learning to monitoring mode) if fewer than learning_rate_numerator
                new clusters are opened in the last learning_rate_denominator samples
            learning_rate_denominator (int): see learning_rate_numerator
            learning_max_clusters (int): sensor graduates if this many clusters are created
            learning_max_samples (int): sensor graduates if this many samples are processed

        Returns:
            A dictionary containing:

                {
                    &#39;feature_count&#39;: int,
                    &#39;streaming_window_size&#39;: int,
                    &#39;samples_to_buffer&#39;: int
                    &#39;anomaly_history_window&#39;: int,
                    &#39;learning_rate_numerator&#39;: int,
                    &#39;learning_rate_denominator&#39;: int,
                    &#39;learning_max_clusters&#39;: int,
                    &#39;learning_max_samples&#39;: int
                }

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid options
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;
        if not feature_count &gt; 0 or not isinstance(feature_count, Integral):
            raise AmberUserError(&#34;invalid &#39;feature_count&#39;: must be positive integer&#34;)

        if not streaming_window_size &gt; 0 or not isinstance(streaming_window_size, Integral):
            raise AmberUserError(&#34;invalid &#39;streaming_window_size&#39;: must be positive integer&#34;)

        url = self.license_profile[&#39;server&#39;] + &#39;/config&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;featureCount&#39;: feature_count,
            &#39;streamingWindowSize&#39;: streaming_window_size,
            &#39;samplesToBuffer&#39;: samples_to_buffer,
            &#39;anomalyHistoryWindow&#39;: anomaly_history_window,
            &#39;learningRateNumerator&#39;: learning_rate_numerator,
            &#39;learningRateDenominator&#39;: learning_rate_denominator,
            &#39;learningMaxClusters&#39;: learning_max_clusters,
            &#39;learningMaxSamples&#39;: learning_max_samples
        }
        config = self._api_call(&#39;POST&#39;, url, headers, body=body)

        return config

    def _isiterable(self, x):
        # consider strings non-iterable for shape validation purposes,
        # that way they are printed out whole when caught as nonnumeric
        if isinstance(x, str):
            return False

        # collections.abc docs: &#34;The only reliable way to determine
        # whether an object is iterable is to call iter(obj).&#34;
        try:
            iter(x)
        except TypeError:
            return False

        return True

    def _validate_dims(self, data):
        &#34;&#34;&#34;Validate that data is non-empty and one of the following:
           scalar value, list-like or list-of-lists-like where all
           sublists have equal length. Return 0, 1 or 2 as inferred
           number of array dimensions
        &#34;&#34;&#34;

        # not-iterable data is a single scalar data point
        if not self._isiterable(data):
            return 0

        # iterable and unnested data is a 1-d array
        if not any(self._isiterable(d) for d in data):
            if len(list(data)) == 0:
                raise ValueError(&#34;empty&#34;)

            return 1

        # iterable and nested data is 2-d array
        if not all(self._isiterable(d) for d in data):
            raise ValueError(&#34;cannot mix nested scalars and iterables&#34;)

        sublengths = [len(list(d)) for d in data]
        if len(set(sublengths)) &gt; 1:
            raise ValueError(&#34;nested sublists must have equal length&#34;)

        flattened_2d = list(itertools.chain.from_iterable(data))

        if any(isinstance(i, Iterable) for i in flattened_2d):
            raise ValueError(&#34;cannot be nested deeper than list-of-lists&#34;)

        if sublengths[0] == 0:
            raise ValueError(&#34;empty&#34;)

        return 2

    def _convert_to_csv(self, data):
        &#34;&#34;&#34;Validate data and convert to a comma-separated plaintext string&#34;&#34;&#34;

        # Note: as in the Boon Nano SDK, there is no check that data dimensions
        # align with number of features and streaming window size.
        ndim = self._validate_dims(data)

        if ndim == 0:
            data_flat = [data]
        elif ndim == 1:
            data_flat = list(data)
        elif ndim == 2:
            data_flat = list(itertools.chain.from_iterable(data))

        for d in data_flat:
            if not isinstance(d, Number):
                raise ValueError(&#34;contained {} which is not numeric&#34;.format(d.__repr__()))

        return &#39;,&#39;.join([str(float(d)) for d in data_flat])

    def pretrain_sensor(self, sensor_id, data, autotune_config=True, block=True):
        &#34;&#34;&#34;Pretrain a sensor with historical data

        Args:
            sensor_id (str): sensor identifier
            data (array-like): data to be inferenced. Must be non-empty,
                entirely numeric and one of the following: scalar value,
                list-like or list-of-lists-like where all sublists have
                equal length.
            autotune_config (bool): if True, the sensor will be reconfigured based
                on the training data provided so that the sensor will be in monitoring
                once the data is through. If False, the sensor uses the already
                configured values to train the sensor.
            block (bool): if True, will block until pretraining is complete.
                Otherwise, will return immediately; in this case pretraining
                status can be checked using get_pretrain_state endpoint.

        Returns:

            {
                &#39;state&#39;: str
            }

            &#39;state&#39;: current state of the sensor.
                &#34;Pretraining&#34;: pretraining is in progress

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid data
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        # Server expects data as a plaintext string of comma-separated values.
        try:
            data_csv = self._convert_to_csv(data)
        except ValueError as e:
            raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

        url = self.license_profile[&#39;server&#39;] + &#39;/pretrain&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;data&#39;: data_csv,
            &#39;autotuneConfig&#39;: autotune_config
        }

        results = self._api_call(&#39;POST&#39;, url, headers, body=body)

        if not block:
            return results

        while True:
            results = self.get_pretrain_state(sensor_id)
            if results[&#39;state&#39;] == &#34;Pretraining&#34;:
                time.sleep(5)
                continue
            else:
                return results

    def get_pretrain_state(self, sensor_id):
        &#34;&#34;&#34;Gets the state of sensor that is being pretrained

        Args:
            sensor_id (str): sensor identifier

        Returns:

            {
                    &#39;state&#39;: str
            }

            &#39;state&#39;: current state of the sensor. One of:
                &#34;Pretraining&#34;: pretraining is in progress
                &#34;Pretrained&#34;: pretraining has completed
                &#34;Error&#34;: error has occurred
        Raises:
            AmberUserError: if client is not authenticated or supplies invalid data
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/pretrain&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }

        results = self._api_call(&#39;GET&#39;, url, headers)

        return results

    def stream_sensor(self, sensor_id, data):
        &#34;&#34;&#34;Stream data to an amber sensor and return the inference result

        Args:
            sensor_id (str): sensor identifier
            data (array-like): data to be inferenced. Must be non-empty,
                entirely numeric and one of the following: scalar value,
                list-like or list-of-lists-like where all sublists have
                equal length.

        Returns:
            A dictionary containing inferencing results:

                {
                    &#39;state&#39;: str,
                    &#39;message&#39;: str,
                    &#39;progress&#39;: int,
                    &#39;clusterCount&#39;: int,
                    &#39;retryCount&#39;: int,
                    &#39;streamingWindowSize&#39;: int,
                    &#39;totalInferences&#39;: int,
                    &#39;ID&#39;: [int],
                    &#39;SI&#39;: [int],
                    &#39;AD&#39;: [int],
                    &#39;AH&#39;: [int],
                    &#39;AM&#39;: [float],
                    &#39;AW&#39;: [int]
                }

                &#39;state&#39;: current state of the sensor. One of:
                    &#34;Buffering&#34;: gathering initial sensor data
                    &#34;Autotuning&#34;: autotuning configuration in progress
                    &#34;Learning&#34;: sensor is active and learning
                    &#34;Monitoring&#34;: sensor is active but monitoring only (learning disabled)
                    &#34;Error&#34;: fatal error has occurred
                &#39;message&#39;: accompanying message for current sensor state
                &#39;progress&#39; progress as a percentage value (applicable for &#34;Buffering&#34; and &#34;Autotuning&#34; states)
                &#39;clusterCount&#39; number of clusters created so far
                &#39;retryCount&#39; number of times autotuning was re-attempted to tune streamingWindowSize
                &#39;streamingWindowSize&#39;: streaming window size of sensor (may differ from value
                    given at configuration if window size was adjusted during autotune)
                &#39;totalInferences&#39;: number of inferences since configuration
                &#39;ID&#39;: list of cluster IDs. The values in this list correspond one-to-one
                    with input samples, indicating the cluster to which each input pattern
                    was assigned.
                &#39;SI&#39;: smoothed anomaly index. The values in this list correspond
                    one-for-one with input samples and range between 0 and 1000. Values
                    closer to 0 represent input patterns which are ordinary given the data
                    seen so far on this sensor. Values closer to 1000 represent novel patterns
                    which are anomalous with respect to data seen before.
                &#39;RI&#39;: raw anomaly index. These values are the SI values without any smoothing.
                &#39;AD&#39;: list of binary anomaly detection values. These correspond one-to-one
                    with input samples and are produced by thresholding the smoothed anomaly
                    index (SI). The threshold is determined automatically from the SI values.
                    A value of 0 indicates that the SI has not exceeded the anomaly detection
                    threshold. A value of 1 indicates it has, signaling an anomaly at the
                    corresponding input sample.
                &#39;AH&#39;: list of anomaly history values. These values are a moving-window sum of
                    the AD value, giving the number of anomaly detections (1&#39;s) present in the
                    AD signal over a &#34;recent history&#34; window whose length is the buffer size.
                &#39;AM&#39;: list of &#34;Amber Metric&#34; values. These are floating point values between
                    0.0 and 1.0 indicating the extent to which each corresponding AH value
                    shows an unusually high number of anomalies in recent history. The values
                    are derived statistically from a Poisson model, with values close to 0.0
                    signaling a lower, and values close to 1.0 signaling a higher, frequency
                    of anomalies than usual.
                &#39;AW&#39;: list of &#34;Amber Warning Level&#34; values. This index is produced by thresholding
                    the Amber Metric (AM) and takes on the values 0, 1 or 2 representing a discrete
                    &#34;warning level&#34; for an asset based on the frequency of anomalies within recent
                    history. 0 = normal, 1 = asset changing, 2 = asset critical. The default
                    thresholds for the two warning levels are the standard statistical values
                    of 0.95 (outlier, asset changing) and 0.997 (extreme outlier, asset critical).

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid data
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        # Server expects data as a plaintext string of comma-separated values.
        try:
            data_csv = self._convert_to_csv(data)
        except ValueError as e:
            raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

        url = self.license_profile[&#39;server&#39;] + &#39;/stream&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;data&#39;: data_csv
        }

        results = self._api_call(&#39;POST&#39;, url, headers, body=body)

        return results

    def get_sensor(self, sensor_id):
        &#34;&#34;&#34;Get info about a sensor

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing sensor information:

                {
                    &#39;label&#39;: str,
                    &#39;sensorId&#39;: str,
                    &#39;usageInfo&#39;: {
                        putSensor {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        getSensor {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        getConfig {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        postStream {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: int
                            &#39;samplesTotal&#39;: int
                            &#39;samplesThisPeriod&#39;: int
                        }
                        getStatus {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        }
                    }
                }

                &#39;label&#39; (str): sensor label
                &#39;sensorId&#39; (str): sensor identifier
                &#39;callsTotal&#39;: total number of calls to this endpoint
                &#39;callsThisPeriod&#39;: calls this billing period to this endpoint
                &#39;lastCalled&#39;: ISO formatted time of last call to this endpoint
                &#39;samplesTotal&#39;: total number of samples processed
                &#39;samplesThisPeriod&#39;: number of samples processed this billing period

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        sensor = self._api_call(&#39;GET&#39;, url, headers)

        return sensor

    def get_config(self, sensor_id):
        &#34;&#34;&#34;Get current sensor configuration

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing the current sensor configuration:

                {
                    &#39;featureCount&#39;: int,
                    &#39;streamingWindowSize&#39;: int,
                    &#39;samplesToBuffer&#39;: int,
                    &#39;anomalyHistoryWindow&#39;: int,
                    &#39;learningRateNumerator&#39;: int,
                    &#39;learningRateDenominator&#39;: int,
                    &#39;learningMaxClusters&#39;: int,
                    &#39;learningMaxSamples&#39;: int,
                    &#39;percentVariation&#39;: float,
                    &#39;features&#39;:
                    [
                        {
                            &#39;min&#39;: float,
                            &#39;max&#39;: float
                        }
                    ]
                }

                &#39;featureCount&#39;: number of features (dimensionality of each data sample)
                &#39;streamingWindowSize&#39;: streaming window size (number of samples)
                &#39;samplesToBuffer&#39;: number of samples to load before autotuning
                &#39;anomalyHistoryWindow&#39;: number of samples to calculate normal anomaly variation
                &#39;learningRateNumerator&#39;: sensor &#34;graduates&#34; (i.e. transitions from
                    learning to monitoring mode) if fewer than learning_rate_numerator
                    new clusters are opened in the last learning_rate_denominator samples
                &#39;learningRateDenominator&#39;: see learning_rate_numerator
                &#39;learningMaxClusters&#39;: sensor graduates if this many clusters are created
                &#39;learningMaxSamples&#39;: sensor graduates if this many samples are processed
                &#39;percentVariation&#39;: percent variation parameter discovered by autotuning
                &#39;features&#39;: min/max values per feature discovered by autotuning
        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/config&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        config = self._api_call(&#39;GET&#39;, url, headers)

        return config

    def get_status(self, sensor_id):
        &#34;&#34;&#34;Get sensor status

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing the clustering status for a sensor:

                {
                    &#39;pca&#39; [(int,int,int)],
                    &#39;clusterGrowth&#39; [int],
                    &#39;clusterSizes&#39; [int],
                    &#39;anomalyIndexes&#39; [int],
                    &#39;frequencyIndexes&#39; [int],
                    &#39;distanceIndexes&#39; [int],
                    &#39;totalInferences&#39; [int],
                    &#39;numClusters&#39; [int],
                }

                &#39;pca&#39;: list of length-3 vectors representing cluster centroids
                    with dimensionality reduced to 3 principal components. List length
                    is one plus the maximum cluster ID, with element 0 corresponding
                    to the &#34;zero&#34; cluster, element 1 corresponding to cluster ID 1, etc.
                &#39;clusterGrowth&#39;: sample index at which each new cluster was created.
                    Elements for this and other list results are ordered as in &#39;pca&#39;.
                &#39;clusterSizes&#39;: number of samples in each cluster
                &#39;anomalyIndexes&#39;: anomaly index associated with each cluster
                &#39;frequencyIndexes&#39;: frequency index associated with each cluster
                &#39;distanceIndexes&#39;: distance index associated with each cluster
                &#39;totalInferences&#39;: total number of inferences performed so far
                &#39;numClusters&#39;: number of clusters created so far (includes zero cluster)

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.license_profile[&#39;server&#39;] + &#39;/status&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        status = self._api_call(&#39;GET&#39;, url, headers)

        return status

    def get_root_cause(self, sensor_id, id_list=[], pattern_list=[]):
        &#34;&#34;&#34;Get root cause

        Args:
            sensor_id (str): sensor identifier
            id_list (list): list of IDs to return the root cause for
            pattern_list (list): list of pattern vectors to calculate the root cause against the model

        Returns:
            A list containing the root cause for each pattern/id provided for a sensor:

                [float]

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        if len(id_list) != 0 and len(pattern_list) != 0:
            raise AmberUserError(&#39;Cannot specify both patterns and cluster IDs for analysis&#39;)
        url_call = &#39;rootCause?&#39;
        if len(id_list) != 0:
            # IDs
            id_list = [str(element) for element in id_list]
            url_call = url_call + &#39;clusterID=[&#39; + &#34;,&#34;.join(id_list) + &#39;]&#39;
        elif len(pattern_list) != 0:
            # patterns
            if len(np.array(pattern_list).shape) == 1:  # only 1 pattern provided
                pattern_list = [pattern_list]
            else:
                for i, pattern in enumerate(pattern_list):
                    pattern_list[i] = &#39;,&#39;.join([str(element) for element in pattern])
            url_call = url_call + &#39;pattern=[[&#39; + &#34;],[&#34;.join(pattern_list) + &#39;]]&#39;
        else:
            raise AmberUserError(&#39;Must specify either cluster IDs or patterns to analyze&#39;)

        url = self.license_profile[&#39;server&#39;] + &#39;/&#39; + url_call
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        status = self._api_call(&#39;GET&#39;, url, headers)

        return status</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="boonamber.AmberClient.configure_sensor"><code class="name flex">
<span>def <span class="ident">configure_sensor</span></span>(<span>self, sensor_id, feature_count=1, streaming_window_size=25, samples_to_buffer=10000, anomaly_history_window=10000, learning_rate_numerator=10, learning_rate_denominator=10000, learning_max_clusters=1000, learning_max_samples=1000000)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure an amber sensor instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
<dt><strong><code>feature_count</code></strong> :&ensp;<code>int</code></dt>
<dd>number of features (dimensionality of each data sample)</dd>
<dt><strong><code>streaming_window_size</code></strong> :&ensp;<code>int</code></dt>
<dd>streaming window size (number of samples)</dd>
<dt><strong><code>samples_to_buffer</code></strong> :&ensp;<code>int</code></dt>
<dd>number of samples to load before autotuning</dd>
<dt><strong><code>anomaly_history_window</code></strong> :&ensp;<code>int</code></dt>
<dd>number of samples to use for AH calculation</dd>
<dt><strong><code>learning_rate_numerator</code></strong> :&ensp;<code>int</code></dt>
<dd>sensor "graduates" (i.e. transitions from
learning to monitoring mode) if fewer than learning_rate_numerator
new clusters are opened in the last learning_rate_denominator samples</dd>
<dt><strong><code>learning_rate_denominator</code></strong> :&ensp;<code>int</code></dt>
<dd>see learning_rate_numerator</dd>
<dt><strong><code>learning_max_clusters</code></strong> :&ensp;<code>int</code></dt>
<dd>sensor graduates if this many clusters are created</dd>
<dt><strong><code>learning_max_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>sensor graduates if this many samples are processed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing:</p>
<pre><code>{
    'feature_count': int,
    'streaming_window_size': int,
    'samples_to_buffer': int
    'anomaly_history_window': int,
    'learning_rate_numerator': int,
    'learning_rate_denominator': int,
    'learning_max_clusters': int,
    'learning_max_samples': int
}
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated or supplies invalid options</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_sensor(self, sensor_id, feature_count=1, streaming_window_size=25,
                     samples_to_buffer=10000,
                     anomaly_history_window=10000,
                     learning_rate_numerator=10,
                     learning_rate_denominator=10000,
                     learning_max_clusters=1000,
                     learning_max_samples=1000000):
    &#34;&#34;&#34;Configure an amber sensor instance

    Args:
        sensor_id (str): sensor identifier
        feature_count (int): number of features (dimensionality of each data sample)
        streaming_window_size (int): streaming window size (number of samples)
        samples_to_buffer (int): number of samples to load before autotuning
        anomaly_history_window (int): number of samples to use for AH calculation
        learning_rate_numerator (int): sensor &#34;graduates&#34; (i.e. transitions from
            learning to monitoring mode) if fewer than learning_rate_numerator
            new clusters are opened in the last learning_rate_denominator samples
        learning_rate_denominator (int): see learning_rate_numerator
        learning_max_clusters (int): sensor graduates if this many clusters are created
        learning_max_samples (int): sensor graduates if this many samples are processed

    Returns:
        A dictionary containing:

            {
                &#39;feature_count&#39;: int,
                &#39;streaming_window_size&#39;: int,
                &#39;samples_to_buffer&#39;: int
                &#39;anomaly_history_window&#39;: int,
                &#39;learning_rate_numerator&#39;: int,
                &#39;learning_rate_denominator&#39;: int,
                &#39;learning_max_clusters&#39;: int,
                &#39;learning_max_samples&#39;: int
            }

    Raises:
        AmberUserError: if client is not authenticated or supplies invalid options
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;
    if not feature_count &gt; 0 or not isinstance(feature_count, Integral):
        raise AmberUserError(&#34;invalid &#39;feature_count&#39;: must be positive integer&#34;)

    if not streaming_window_size &gt; 0 or not isinstance(streaming_window_size, Integral):
        raise AmberUserError(&#34;invalid &#39;streaming_window_size&#39;: must be positive integer&#34;)

    url = self.license_profile[&#39;server&#39;] + &#39;/config&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    body = {
        &#39;featureCount&#39;: feature_count,
        &#39;streamingWindowSize&#39;: streaming_window_size,
        &#39;samplesToBuffer&#39;: samples_to_buffer,
        &#39;anomalyHistoryWindow&#39;: anomaly_history_window,
        &#39;learningRateNumerator&#39;: learning_rate_numerator,
        &#39;learningRateDenominator&#39;: learning_rate_denominator,
        &#39;learningMaxClusters&#39;: learning_max_clusters,
        &#39;learningMaxSamples&#39;: learning_max_samples
    }
    config = self._api_call(&#39;POST&#39;, url, headers, body=body)

    return config</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.create_sensor"><code class="name flex">
<span>def <span class="ident">create_sensor</span></span>(<span>self, label='')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new sensor instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>label to assign to created sensor</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing the <code>sensor_id</code> that was created</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_sensor(self, label=&#39;&#39;):
    &#34;&#34;&#34;Create a new sensor instance

    Args:
        label (str): label to assign to created sensor

    Returns:
        A string containing the `sensor_id` that was created

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;
    }
    body = {
        &#39;label&#39;: label
    }
    response = self._api_call(&#39;POST&#39;, url, headers, body=body)
    sensor_id = response[&#39;sensorId&#39;]

    return sensor_id</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.delete_sensor"><code class="name flex">
<span>def <span class="ident">delete_sensor</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete an amber sensor instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_sensor(self, sensor_id):
    &#34;&#34;&#34;Delete an amber sensor instance

    Args:
        sensor_id (str): sensor identifier

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    response = self._api_call(&#39;DELETE&#39;, url, headers)</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current sensor configuration</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing the current sensor configuration:</p>
<pre><code>{
    'featureCount': int,
    'streamingWindowSize': int,
    'samplesToBuffer': int,
    'anomalyHistoryWindow': int,
    'learningRateNumerator': int,
    'learningRateDenominator': int,
    'learningMaxClusters': int,
    'learningMaxSamples': int,
    'percentVariation': float,
    'features':
    [
        {
            'min': float,
            'max': float
        }
    ]
}

'featureCount': number of features (dimensionality of each data sample)
'streamingWindowSize': streaming window size (number of samples)
'samplesToBuffer': number of samples to load before autotuning
'anomalyHistoryWindow': number of samples to calculate normal anomaly variation
'learningRateNumerator': sensor "graduates" (i.e. transitions from
    learning to monitoring mode) if fewer than learning_rate_numerator
    new clusters are opened in the last learning_rate_denominator samples
'learningRateDenominator': see learning_rate_numerator
'learningMaxClusters': sensor graduates if this many clusters are created
'learningMaxSamples': sensor graduates if this many samples are processed
'percentVariation': percent variation parameter discovered by autotuning
'features': min/max values per feature discovered by autotuning
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self, sensor_id):
    &#34;&#34;&#34;Get current sensor configuration

    Args:
        sensor_id (str): sensor identifier

    Returns:
        A dictionary containing the current sensor configuration:

            {
                &#39;featureCount&#39;: int,
                &#39;streamingWindowSize&#39;: int,
                &#39;samplesToBuffer&#39;: int,
                &#39;anomalyHistoryWindow&#39;: int,
                &#39;learningRateNumerator&#39;: int,
                &#39;learningRateDenominator&#39;: int,
                &#39;learningMaxClusters&#39;: int,
                &#39;learningMaxSamples&#39;: int,
                &#39;percentVariation&#39;: float,
                &#39;features&#39;:
                [
                    {
                        &#39;min&#39;: float,
                        &#39;max&#39;: float
                    }
                ]
            }

            &#39;featureCount&#39;: number of features (dimensionality of each data sample)
            &#39;streamingWindowSize&#39;: streaming window size (number of samples)
            &#39;samplesToBuffer&#39;: number of samples to load before autotuning
            &#39;anomalyHistoryWindow&#39;: number of samples to calculate normal anomaly variation
            &#39;learningRateNumerator&#39;: sensor &#34;graduates&#34; (i.e. transitions from
                learning to monitoring mode) if fewer than learning_rate_numerator
                new clusters are opened in the last learning_rate_denominator samples
            &#39;learningRateDenominator&#39;: see learning_rate_numerator
            &#39;learningMaxClusters&#39;: sensor graduates if this many clusters are created
            &#39;learningMaxSamples&#39;: sensor graduates if this many samples are processed
            &#39;percentVariation&#39;: percent variation parameter discovered by autotuning
            &#39;features&#39;: min/max values per feature discovered by autotuning
    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/config&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    config = self._api_call(&#39;GET&#39;, url, headers)

    return config</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_pretrain_state"><code class="name flex">
<span>def <span class="ident">get_pretrain_state</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the state of sensor that is being pretrained</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>{
'state': str
}</p>
<p>'state': current state of the sensor. One of:
"Pretraining": pretraining is in progress
"Pretrained": pretraining has completed
"Error": error has occurred</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated or supplies invalid data</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pretrain_state(self, sensor_id):
    &#34;&#34;&#34;Gets the state of sensor that is being pretrained

    Args:
        sensor_id (str): sensor identifier

    Returns:

        {
                &#39;state&#39;: str
        }

        &#39;state&#39;: current state of the sensor. One of:
            &#34;Pretraining&#34;: pretraining is in progress
            &#34;Pretrained&#34;: pretraining has completed
            &#34;Error&#34;: error has occurred
    Raises:
        AmberUserError: if client is not authenticated or supplies invalid data
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/pretrain&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }

    results = self._api_call(&#39;GET&#39;, url, headers)

    return results</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_root_cause"><code class="name flex">
<span>def <span class="ident">get_root_cause</span></span>(<span>self, sensor_id, id_list=[], pattern_list=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Get root cause</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
<dt><strong><code>id_list</code></strong> :&ensp;<code>list</code></dt>
<dd>list of IDs to return the root cause for</dd>
<dt><strong><code>pattern_list</code></strong> :&ensp;<code>list</code></dt>
<dd>list of pattern vectors to calculate the root cause against the model</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list containing the root cause for each pattern/id provided for a sensor:</p>
<pre><code>[float]
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_root_cause(self, sensor_id, id_list=[], pattern_list=[]):
    &#34;&#34;&#34;Get root cause

    Args:
        sensor_id (str): sensor identifier
        id_list (list): list of IDs to return the root cause for
        pattern_list (list): list of pattern vectors to calculate the root cause against the model

    Returns:
        A list containing the root cause for each pattern/id provided for a sensor:

            [float]

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    if len(id_list) != 0 and len(pattern_list) != 0:
        raise AmberUserError(&#39;Cannot specify both patterns and cluster IDs for analysis&#39;)
    url_call = &#39;rootCause?&#39;
    if len(id_list) != 0:
        # IDs
        id_list = [str(element) for element in id_list]
        url_call = url_call + &#39;clusterID=[&#39; + &#34;,&#34;.join(id_list) + &#39;]&#39;
    elif len(pattern_list) != 0:
        # patterns
        if len(np.array(pattern_list).shape) == 1:  # only 1 pattern provided
            pattern_list = [pattern_list]
        else:
            for i, pattern in enumerate(pattern_list):
                pattern_list[i] = &#39;,&#39;.join([str(element) for element in pattern])
        url_call = url_call + &#39;pattern=[[&#39; + &#34;],[&#34;.join(pattern_list) + &#39;]]&#39;
    else:
        raise AmberUserError(&#39;Must specify either cluster IDs or patterns to analyze&#39;)

    url = self.license_profile[&#39;server&#39;] + &#39;/&#39; + url_call
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    status = self._api_call(&#39;GET&#39;, url, headers)

    return status</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_sensor"><code class="name flex">
<span>def <span class="ident">get_sensor</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get info about a sensor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing sensor information:</p>
<pre><code>{
    'label': str,
    'sensorId': str,
    'usageInfo': {
        putSensor {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': str
        },
        getSensor {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': str
        },
        getConfig {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': str
        },
        postStream {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': int
            'samplesTotal': int
            'samplesThisPeriod': int
        }
        getStatus {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': str
        }
    }
}

'label' (str): sensor label
'sensorId' (str): sensor identifier
'callsTotal': total number of calls to this endpoint
'callsThisPeriod': calls this billing period to this endpoint
'lastCalled': ISO formatted time of last call to this endpoint
'samplesTotal': total number of samples processed
'samplesThisPeriod': number of samples processed this billing period
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sensor(self, sensor_id):
    &#34;&#34;&#34;Get info about a sensor

    Args:
        sensor_id (str): sensor identifier

    Returns:
        A dictionary containing sensor information:

            {
                &#39;label&#39;: str,
                &#39;sensorId&#39;: str,
                &#39;usageInfo&#39;: {
                    putSensor {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: str
                    },
                    getSensor {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: str
                    },
                    getConfig {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: str
                    },
                    postStream {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: int
                        &#39;samplesTotal&#39;: int
                        &#39;samplesThisPeriod&#39;: int
                    }
                    getStatus {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: str
                    }
                }
            }

            &#39;label&#39; (str): sensor label
            &#39;sensorId&#39; (str): sensor identifier
            &#39;callsTotal&#39;: total number of calls to this endpoint
            &#39;callsThisPeriod&#39;: calls this billing period to this endpoint
            &#39;lastCalled&#39;: ISO formatted time of last call to this endpoint
            &#39;samplesTotal&#39;: total number of samples processed
            &#39;samplesThisPeriod&#39;: number of samples processed this billing period

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    sensor = self._api_call(&#39;GET&#39;, url, headers)

    return sensor</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get sensor status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing the clustering status for a sensor:</p>
<pre><code>{
    'pca' [(int,int,int)],
    'clusterGrowth' [int],
    'clusterSizes' [int],
    'anomalyIndexes' [int],
    'frequencyIndexes' [int],
    'distanceIndexes' [int],
    'totalInferences' [int],
    'numClusters' [int],
}

'pca': list of length-3 vectors representing cluster centroids
    with dimensionality reduced to 3 principal components. List length
    is one plus the maximum cluster ID, with element 0 corresponding
    to the "zero" cluster, element 1 corresponding to cluster ID 1, etc.
'clusterGrowth': sample index at which each new cluster was created.
    Elements for this and other list results are ordered as in 'pca'.
'clusterSizes': number of samples in each cluster
'anomalyIndexes': anomaly index associated with each cluster
'frequencyIndexes': frequency index associated with each cluster
'distanceIndexes': distance index associated with each cluster
'totalInferences': total number of inferences performed so far
'numClusters': number of clusters created so far (includes zero cluster)
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self, sensor_id):
    &#34;&#34;&#34;Get sensor status

    Args:
        sensor_id (str): sensor identifier

    Returns:
        A dictionary containing the clustering status for a sensor:

            {
                &#39;pca&#39; [(int,int,int)],
                &#39;clusterGrowth&#39; [int],
                &#39;clusterSizes&#39; [int],
                &#39;anomalyIndexes&#39; [int],
                &#39;frequencyIndexes&#39; [int],
                &#39;distanceIndexes&#39; [int],
                &#39;totalInferences&#39; [int],
                &#39;numClusters&#39; [int],
            }

            &#39;pca&#39;: list of length-3 vectors representing cluster centroids
                with dimensionality reduced to 3 principal components. List length
                is one plus the maximum cluster ID, with element 0 corresponding
                to the &#34;zero&#34; cluster, element 1 corresponding to cluster ID 1, etc.
            &#39;clusterGrowth&#39;: sample index at which each new cluster was created.
                Elements for this and other list results are ordered as in &#39;pca&#39;.
            &#39;clusterSizes&#39;: number of samples in each cluster
            &#39;anomalyIndexes&#39;: anomaly index associated with each cluster
            &#39;frequencyIndexes&#39;: frequency index associated with each cluster
            &#39;distanceIndexes&#39;: distance index associated with each cluster
            &#39;totalInferences&#39;: total number of inferences performed so far
            &#39;numClusters&#39;: number of clusters created so far (includes zero cluster)

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/status&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    status = self._api_call(&#39;GET&#39;, url, headers)

    return status</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_version"><code class="name flex">
<span>def <span class="ident">get_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get version information for Amber</p>
<h2 id="returns">Returns</h2>
<p>json version information</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_version(self):
    &#34;&#34;&#34;Get version information for Amber

    Returns:
        json version information

    Raises:
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/version&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;
    }
    response = self._api_call(&#39;GET&#39;, url, headers)

    return response</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.list_sensors"><code class="name flex">
<span>def <span class="ident">list_sensors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List all sensor instances currently associated with Amber account</p>
<h2 id="returns">Returns</h2>
<p>A dictionary mapping sensor IDs to corresponding labels</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_sensors(self):
    &#34;&#34;&#34;List all sensor instances currently associated with Amber account

    Returns:
        A dictionary mapping sensor IDs to corresponding labels

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/sensors&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;
    }
    response = self._api_call(&#39;GET&#39;, url, headers)
    sensors = {s[&#39;sensorId&#39;]: s.get(&#39;label&#39;, None) for s in response}

    return sensors</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.pretrain_sensor"><code class="name flex">
<span>def <span class="ident">pretrain_sensor</span></span>(<span>self, sensor_id, data, autotune_config=True, block=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretrain a sensor with historical data</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>array-like</code></dt>
<dd>data to be inferenced. Must be non-empty,
entirely numeric and one of the following: scalar value,
list-like or list-of-lists-like where all sublists have
equal length.</dd>
<dt><strong><code>autotune_config</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the sensor will be reconfigured based
on the training data provided so that the sensor will be in monitoring
once the data is through. If False, the sensor uses the already
configured values to train the sensor.</dd>
<dt><strong><code>block</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, will block until pretraining is complete.
Otherwise, will return immediately; in this case pretraining
status can be checked using get_pretrain_state endpoint.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>{
'state': str
}</p>
<p>'state': current state of the sensor.
"Pretraining": pretraining is in progress</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated or supplies invalid data</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretrain_sensor(self, sensor_id, data, autotune_config=True, block=True):
    &#34;&#34;&#34;Pretrain a sensor with historical data

    Args:
        sensor_id (str): sensor identifier
        data (array-like): data to be inferenced. Must be non-empty,
            entirely numeric and one of the following: scalar value,
            list-like or list-of-lists-like where all sublists have
            equal length.
        autotune_config (bool): if True, the sensor will be reconfigured based
            on the training data provided so that the sensor will be in monitoring
            once the data is through. If False, the sensor uses the already
            configured values to train the sensor.
        block (bool): if True, will block until pretraining is complete.
            Otherwise, will return immediately; in this case pretraining
            status can be checked using get_pretrain_state endpoint.

    Returns:

        {
            &#39;state&#39;: str
        }

        &#39;state&#39;: current state of the sensor.
            &#34;Pretraining&#34;: pretraining is in progress

    Raises:
        AmberUserError: if client is not authenticated or supplies invalid data
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    # Server expects data as a plaintext string of comma-separated values.
    try:
        data_csv = self._convert_to_csv(data)
    except ValueError as e:
        raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

    url = self.license_profile[&#39;server&#39;] + &#39;/pretrain&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    body = {
        &#39;data&#39;: data_csv,
        &#39;autotuneConfig&#39;: autotune_config
    }

    results = self._api_call(&#39;POST&#39;, url, headers, body=body)

    if not block:
        return results

    while True:
        results = self.get_pretrain_state(sensor_id)
        if results[&#39;state&#39;] == &#34;Pretraining&#34;:
            time.sleep(5)
            continue
        else:
            return results</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.stream_sensor"><code class="name flex">
<span>def <span class="ident">stream_sensor</span></span>(<span>self, sensor_id, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream data to an amber sensor and return the inference result</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>array-like</code></dt>
<dd>data to be inferenced. Must be non-empty,
entirely numeric and one of the following: scalar value,
list-like or list-of-lists-like where all sublists have
equal length.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing inferencing results:</p>
<pre><code>{
    'state': str,
    'message': str,
    'progress': int,
    'clusterCount': int,
    'retryCount': int,
    'streamingWindowSize': int,
    'totalInferences': int,
    'ID': [int],
    'SI': [int],
    'AD': [int],
    'AH': [int],
    'AM': [float],
    'AW': [int]
}

'state': current state of the sensor. One of:
    "Buffering": gathering initial sensor data
    "Autotuning": autotuning configuration in progress
    "Learning": sensor is active and learning
    "Monitoring": sensor is active but monitoring only (learning disabled)
    "Error": fatal error has occurred
'message': accompanying message for current sensor state
'progress' progress as a percentage value (applicable for "Buffering" and "Autotuning" states)
'clusterCount' number of clusters created so far
'retryCount' number of times autotuning was re-attempted to tune streamingWindowSize
'streamingWindowSize': streaming window size of sensor (may differ from value
    given at configuration if window size was adjusted during autotune)
'totalInferences': number of inferences since configuration
'ID': list of cluster IDs. The values in this list correspond one-to-one
    with input samples, indicating the cluster to which each input pattern
    was assigned.
'SI': smoothed anomaly index. The values in this list correspond
    one-for-one with input samples and range between 0 and 1000. Values
    closer to 0 represent input patterns which are ordinary given the data
    seen so far on this sensor. Values closer to 1000 represent novel patterns
    which are anomalous with respect to data seen before.
'RI': raw anomaly index. These values are the SI values without any smoothing.
'AD': list of binary anomaly detection values. These correspond one-to-one
    with input samples and are produced by thresholding the smoothed anomaly
    index (SI). The threshold is determined automatically from the SI values.
    A value of 0 indicates that the SI has not exceeded the anomaly detection
    threshold. A value of 1 indicates it has, signaling an anomaly at the
    corresponding input sample.
'AH': list of anomaly history values. These values are a moving-window sum of
    the AD value, giving the number of anomaly detections (1's) present in the
    AD signal over a "recent history" window whose length is the buffer size.
'AM': list of "Amber Metric" values. These are floating point values between
    0.0 and 1.0 indicating the extent to which each corresponding AH value
    shows an unusually high number of anomalies in recent history. The values
    are derived statistically from a Poisson model, with values close to 0.0
    signaling a lower, and values close to 1.0 signaling a higher, frequency
    of anomalies than usual.
'AW': list of "Amber Warning Level" values. This index is produced by thresholding
    the Amber Metric (AM) and takes on the values 0, 1 or 2 representing a discrete
    "warning level" for an asset based on the frequency of anomalies within recent
    history. 0 = normal, 1 = asset changing, 2 = asset critical. The default
    thresholds for the two warning levels are the standard statistical values
    of 0.95 (outlier, asset changing) and 0.997 (extreme outlier, asset critical).
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated or supplies invalid data</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_sensor(self, sensor_id, data):
    &#34;&#34;&#34;Stream data to an amber sensor and return the inference result

    Args:
        sensor_id (str): sensor identifier
        data (array-like): data to be inferenced. Must be non-empty,
            entirely numeric and one of the following: scalar value,
            list-like or list-of-lists-like where all sublists have
            equal length.

    Returns:
        A dictionary containing inferencing results:

            {
                &#39;state&#39;: str,
                &#39;message&#39;: str,
                &#39;progress&#39;: int,
                &#39;clusterCount&#39;: int,
                &#39;retryCount&#39;: int,
                &#39;streamingWindowSize&#39;: int,
                &#39;totalInferences&#39;: int,
                &#39;ID&#39;: [int],
                &#39;SI&#39;: [int],
                &#39;AD&#39;: [int],
                &#39;AH&#39;: [int],
                &#39;AM&#39;: [float],
                &#39;AW&#39;: [int]
            }

            &#39;state&#39;: current state of the sensor. One of:
                &#34;Buffering&#34;: gathering initial sensor data
                &#34;Autotuning&#34;: autotuning configuration in progress
                &#34;Learning&#34;: sensor is active and learning
                &#34;Monitoring&#34;: sensor is active but monitoring only (learning disabled)
                &#34;Error&#34;: fatal error has occurred
            &#39;message&#39;: accompanying message for current sensor state
            &#39;progress&#39; progress as a percentage value (applicable for &#34;Buffering&#34; and &#34;Autotuning&#34; states)
            &#39;clusterCount&#39; number of clusters created so far
            &#39;retryCount&#39; number of times autotuning was re-attempted to tune streamingWindowSize
            &#39;streamingWindowSize&#39;: streaming window size of sensor (may differ from value
                given at configuration if window size was adjusted during autotune)
            &#39;totalInferences&#39;: number of inferences since configuration
            &#39;ID&#39;: list of cluster IDs. The values in this list correspond one-to-one
                with input samples, indicating the cluster to which each input pattern
                was assigned.
            &#39;SI&#39;: smoothed anomaly index. The values in this list correspond
                one-for-one with input samples and range between 0 and 1000. Values
                closer to 0 represent input patterns which are ordinary given the data
                seen so far on this sensor. Values closer to 1000 represent novel patterns
                which are anomalous with respect to data seen before.
            &#39;RI&#39;: raw anomaly index. These values are the SI values without any smoothing.
            &#39;AD&#39;: list of binary anomaly detection values. These correspond one-to-one
                with input samples and are produced by thresholding the smoothed anomaly
                index (SI). The threshold is determined automatically from the SI values.
                A value of 0 indicates that the SI has not exceeded the anomaly detection
                threshold. A value of 1 indicates it has, signaling an anomaly at the
                corresponding input sample.
            &#39;AH&#39;: list of anomaly history values. These values are a moving-window sum of
                the AD value, giving the number of anomaly detections (1&#39;s) present in the
                AD signal over a &#34;recent history&#34; window whose length is the buffer size.
            &#39;AM&#39;: list of &#34;Amber Metric&#34; values. These are floating point values between
                0.0 and 1.0 indicating the extent to which each corresponding AH value
                shows an unusually high number of anomalies in recent history. The values
                are derived statistically from a Poisson model, with values close to 0.0
                signaling a lower, and values close to 1.0 signaling a higher, frequency
                of anomalies than usual.
            &#39;AW&#39;: list of &#34;Amber Warning Level&#34; values. This index is produced by thresholding
                the Amber Metric (AM) and takes on the values 0, 1 or 2 representing a discrete
                &#34;warning level&#34; for an asset based on the frequency of anomalies within recent
                history. 0 = normal, 1 = asset changing, 2 = asset critical. The default
                thresholds for the two warning levels are the standard statistical values
                of 0.95 (outlier, asset changing) and 0.997 (extreme outlier, asset critical).

    Raises:
        AmberUserError: if client is not authenticated or supplies invalid data
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    # Server expects data as a plaintext string of comma-separated values.
    try:
        data_csv = self._convert_to_csv(data)
    except ValueError as e:
        raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

    url = self.license_profile[&#39;server&#39;] + &#39;/stream&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    body = {
        &#39;data&#39;: data_csv
    }

    results = self._api_call(&#39;POST&#39;, url, headers, body=body)

    return results</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.update_label"><code class="name flex">
<span>def <span class="ident">update_label</span></span>(<span>self, sensor_id, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the label of a sensor instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>new label to assign to sensor</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing the new label assigned to sensor</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_label(self, sensor_id, label):
    &#34;&#34;&#34;Update the label of a sensor instance

    Args:
        sensor_id (str): sensor identifier
        label (str): new label to assign to sensor

    Returns:
        A string containing the new label assigned to sensor

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.license_profile[&#39;server&#39;] + &#39;/sensor&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    body = {
        &#39;label&#39;: label
    }
    response = self._api_call(&#39;PUT&#39;, url, headers, body=body)
    label = response[&#39;label&#39;]

    return label</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boonamber.AmberCloudError"><code class="flex name class">
<span>class <span class="ident">AmberCloudError</span></span>
<span>(</span><span>code, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised upon any non-200 response from the Amber cloud</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmberCloudError(Exception):
    &#34;&#34;&#34;Raised upon any non-200 response from the Amber cloud&#34;&#34;&#34;

    def __init__(self, code, message):
        self.code = code
        self.message = message
        super().__init__(&#34;{}: {}&#34;.format(code, message))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="boonamber.AmberUserError"><code class="flex name class">
<span>class <span class="ident">AmberUserError</span></span>
<span>(</span><span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised to indicate an error in SDK usage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmberUserError(Exception):
    &#34;&#34;&#34;Raised to indicate an error in SDK usage&#34;&#34;&#34;

    def __init__(self, message):
        self.message = message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="boonamber.AmberClient" href="#boonamber.AmberClient">AmberClient</a></code></h4>
<ul class="two-column">
<li><code><a title="boonamber.AmberClient.configure_sensor" href="#boonamber.AmberClient.configure_sensor">configure_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.create_sensor" href="#boonamber.AmberClient.create_sensor">create_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.delete_sensor" href="#boonamber.AmberClient.delete_sensor">delete_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.get_config" href="#boonamber.AmberClient.get_config">get_config</a></code></li>
<li><code><a title="boonamber.AmberClient.get_pretrain_state" href="#boonamber.AmberClient.get_pretrain_state">get_pretrain_state</a></code></li>
<li><code><a title="boonamber.AmberClient.get_root_cause" href="#boonamber.AmberClient.get_root_cause">get_root_cause</a></code></li>
<li><code><a title="boonamber.AmberClient.get_sensor" href="#boonamber.AmberClient.get_sensor">get_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.get_status" href="#boonamber.AmberClient.get_status">get_status</a></code></li>
<li><code><a title="boonamber.AmberClient.get_version" href="#boonamber.AmberClient.get_version">get_version</a></code></li>
<li><code><a title="boonamber.AmberClient.list_sensors" href="#boonamber.AmberClient.list_sensors">list_sensors</a></code></li>
<li><code><a title="boonamber.AmberClient.pretrain_sensor" href="#boonamber.AmberClient.pretrain_sensor">pretrain_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.stream_sensor" href="#boonamber.AmberClient.stream_sensor">stream_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.update_label" href="#boonamber.AmberClient.update_label">update_label</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></h4>
</li>
<li>
<h4><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>