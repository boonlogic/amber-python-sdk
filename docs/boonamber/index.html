<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>boonamber API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>boonamber</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
import json
import os
import requests
import time
from collections.abc import Iterable
from numbers import Number, Integral


############################
# Boon Amber Python SDK v1 #
############################


class AmberUserError(Exception):
    &#34;&#34;&#34;Raised to indicate an error in SDK usage&#34;&#34;&#34;

    def __init__(self, message):
        self.message = message


class AmberCloudError(Exception):
    &#34;&#34;&#34;Raised upon any non-200 response from the Amber cloud&#34;&#34;&#34;

    def __init__(self, code, message):
        self.code = code
        self.message = message
        super().__init__(&#34;{}: {}&#34;.format(code, message))


class AmberClient():
    def __init__(self, license_id=&#39;default&#39;, license_file=&#34;~/.Amber.license&#34;):
        &#34;&#34;&#34;Main client which interfaces with the Amber cloud. Amber account
        credentials are discovered within a .Amber.license file located in the
        home directory, or optionally overridden using environment variables.

        Args:
            license_id (str): license identifier label found within .Amber.license file
            license_file (str): path to .Amber.license file
        
        Environment:

            `AMBER_LICENSE_FILE`: sets license_file path

            `AMBER_LICENSE_ID`: sets license_id

            `AMBER_USERNAME`: overrides the username as found in .Amber.license file

            `AMBER_PASSWORD`: overrides the password as found in .Amber.license file

            `AMBER_SERVER`: overrides the server as found in .Amber.license file

        Raises:
            AmberUserError: if error supplying authentication credentials
        &#34;&#34;&#34;

        self.token = None
        self.reauth_time = time.time()

        env_license_file = os.environ.get(&#39;AMBER_LICENSE_FILE&#39;, None)
        env_license_id = os.environ.get(&#39;AMBER_LICENSE_ID&#39;, None)
        env_username = os.environ.get(&#39;AMBER_USERNAME&#39;, None)
        env_password = os.environ.get(&#39;AMBER_PASSWORD&#39;, None)
        env_server = os.environ.get(&#39;AMBER_SERVER&#39;, None)

        # if username, password and server are all specified via environment, we&#39;re done here
        if env_username and env_password and env_server:
            self.username = env_username
            self.password = env_password
            self.server = env_server
            return

        # otherwise we acquire either or both of them from license file
        license_file = env_license_file if env_license_file else license_file
        license_id = env_license_id if env_license_id else license_id

        license_path = os.path.expanduser(license_file)
        if not os.path.exists(license_path):
            raise AmberUserError(&#34;license file {} does not exist&#34;.format(license_path))

        try:
            with open(license_path, &#39;r&#39;) as f:
                file_data = json.load(f)
        except json.JSONDecodeError as e:
            raise AmberUserError(
                &#34;JSON formatting error in license file: {}, line: {}, col: {}&#34;.format(e.msg, e.lineno, e.colno))

        try:
            license_data = file_data[license_id]
        except KeyError:
            raise AmberUserError(&#34;license_id \&#34;{}\&#34; not found in license file&#34;.format(license_id))

        # load the username, password and server, still giving precedence to environment
        try:
            self.username = env_username if env_username else license_data[&#39;username&#39;]
        except KeyError:
            raise AmberUserError(&#34;\&#34;username\&#34; is missing from the specified license in license file&#34;)

        try:
            self.password = env_password if env_password else license_data[&#39;password&#39;]
        except KeyError:
            raise AmberUserError(&#34;\&#34;password\&#34; is missing from the specified license in license file&#34;)

        try:
            self.server = env_server if env_server else license_data[&#39;server&#39;]
        except KeyError:
            raise AmberUserError(&#34;\&#34;server\&#34; is missing from the specified license in license file&#34;)

    def _authenticate(self):
        &#34;&#34;&#34;Authenticate client for the next hour using the credentials given at
        initialization. This acquires and stores an oauth2 token which remains
        valid for one hour and is used to authenticate all other API requests.

        Raises:
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/oauth2&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        body = {
            &#39;username&#39;: self.username,
            &#39;password&#39;: self.password
        }

        response = requests.request(method=&#39;POST&#39;, url=url, headers=headers, json=body)

        if response.status_code != 200:
            message = &#34;authentication failed: {}&#34;.format(response.json()[&#39;message&#39;])
            raise AmberCloudError(response.status_code, message)

        # invalid credentials return a 200 where token is an empty string
        if not response.json()[&#39;idToken&#39;]:
            raise AmberCloudError(401, &#34;authentication failed: invalid credentials&#34;)

        self.token = response.json()[&#39;idToken&#39;]

        expire_secs = int(response.json()[&#39;expiresIn&#39;])
        self.reauth_time = time.time() + expire_secs - 60

    def _api_call(self, method, url, headers, body=None):
        &#34;&#34;&#34;Make a REST call to the Amber server and handle the response&#34;&#34;&#34;

        if time.time() &gt; self.reauth_time:
            self._authenticate()

        headers[&#39;Authorization&#39;] = &#39;Bearer {}&#39;.format(self.token)
        response = requests.request(method=method, url=url, headers=headers, json=body)

        if response.status_code != 200:
            raise AmberCloudError(response.status_code, response.json()[&#39;message&#39;])

        # todo: why 200 status codes with error codes/message in body instead?
        if &#39;code&#39; in response.json() and response.json()[&#39;code&#39;] != 200:
            raise AmberCloudError(response.json()[&#39;code&#39;], response.json()[&#39;message&#39;])

        # lambda runtime errors return 200 with errorMessage in response body
        if &#39;errorMessage&#39; in response.json():
            raise AmberCloudError(500, response.json()[&#39;errorMessage&#39;])

        return response.json()

    def create_sensor(self, label=&#39;&#39;):
        &#34;&#34;&#34;Create a new sensor instance

        Args:
            label (str): label to assign to created sensor

        Returns:
            A string containing the `sensor_id` that was created

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        body = {
            &#39;label&#39;: label
        }
        response = self._api_call(&#39;POST&#39;, url, headers, body=body)
        sensor_id = response[&#39;sensorId&#39;]

        return sensor_id

    def update_label(self, sensor_id, label):
        &#34;&#34;&#34;Update the label of a sensor instance

        Args:
            sensor_id (str): sensor identifier
            label (str): new label to assign to sensor

        Returns:
            A string containing the new label assigned to sensor

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;label&#39;: label
        }
        response = self._api_call(&#39;PUT&#39;, url, headers, body=body)
        label = response[&#39;label&#39;]

        return label

    def delete_sensor(self, sensor_id):
        &#34;&#34;&#34;Delete an amber sensor instance

        Args:
            sensor_id (str): sensor identifier

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        response = self._api_call(&#39;DELETE&#39;, url, headers)

    def list_sensors(self):
        &#34;&#34;&#34;List all sensor instances currently associated with Amber account

        Returns:
            A dictionary mapping sensor IDs to corresponding labels

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensors&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        response = self._api_call(&#39;GET&#39;, url, headers)
        sensors = {s[&#39;sensorId&#39;]: s.get(&#39;label&#39;, None) for s in response}

        return sensors

    def configure_sensor(self, sensor_id, feature_count=1, streaming_window_size=25,
                         samples_to_buffer=10000,
                         learning_rate_numerator=10,
                         learning_rate_denominator=10000,
                         learning_max_clusters=1000,
                         learning_max_samples=1000000):
        &#34;&#34;&#34;Configure an amber sensor instance

        Args:
            sensor_id (str): sensor identifier
            feature_count (int): number of features (dimensionality of each data sample)
            streaming_window_size (int): streaming window size (number of samples)
            samples_to_buffer (int): number of samples to load before autotuning
            learning_rate_numerator (int): sensor &#34;graduates&#34; (i.e. transitions from
                learning to monitoring mode) if fewer than learning_rate_numerator
                new clusters are opened in the last learning_rate_denominator samples
            learning_rate_denominator (int): see learning_rate_numerator
            learning_max_clusters (int): sensor graduates if this many clusters are created
            learning_max_samples (int): sensor graduates if this many samples are processed

        Returns:
            A dictionary containing:

                {
                    &#39;feature_count&#39;: int,
                    &#39;streaming_window_size&#39;: int,
                    &#39;samples_to_buffer&#39;: int
                    &#39;learning_rate_numerator&#39;: int
                    &#39;learning_rate_denominator&#39;: int
                    &#39;learning_max_clusters&#39;: int
                    &#39;learning_max_samples&#39;: int
                }

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid options
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;
        if not feature_count &gt; 0 or not isinstance(feature_count, Integral):
            raise AmberUserError(&#34;invalid &#39;feature_count&#39;: must be positive integer&#34;)

        if not streaming_window_size &gt; 0 or not isinstance(streaming_window_size, Integral):
            raise AmberUserError(&#34;invalid &#39;streaming_window_size&#39;: must be positive integer&#34;)

        url = self.server + &#39;/config&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;featureCount&#39;: feature_count,
            &#39;streamingWindowSize&#39;: streaming_window_size,
            &#39;samplesToBuffer&#39;: samples_to_buffer,
            &#39;learningRateNumerator&#39;: learning_rate_numerator,
            &#39;learningRateDenominator&#39;: learning_rate_denominator,
            &#39;learningMaxClusters&#39;: learning_max_clusters,
            &#39;learningMaxSamples&#39;: learning_max_samples
        }
        config = self._api_call(&#39;POST&#39;, url, headers, body=body)

        return config

    def _isiterable(self, x):
        # consider strings non-iterable for shape validation purposes,
        # that way they are printed out whole when caught as nonnumeric
        if isinstance(x, str):
            return False

        # collections.abc docs: &#34;The only reliable way to determine
        # whether an object is iterable is to call iter(obj).&#34;
        try:
            iter(x)
        except TypeError:
            return False

        return True

    def _validate_dims(self, data):
        &#34;&#34;&#34;Validate that data is non-empty and one of the following:
           scalar value, list-like or list-of-lists-like where all
           sublists have equal length. Return 0, 1 or 2 as inferred
           number of array dimensions
        &#34;&#34;&#34;

        # not-iterable data is a single scalar data point
        if not self._isiterable(data):
            return 0

        # iterable and unnested data is a 1-d array
        if not any(self._isiterable(d) for d in data):
            if len(list(data)) == 0:
                raise ValueError(&#34;empty&#34;)

            return 1

        # iterable and nested data is 2-d array
        if not all(self._isiterable(d) for d in data):
            raise ValueError(&#34;cannot mix nested scalars and iterables&#34;)

        sublengths = [len(list(d)) for d in data]
        if len(set(sublengths)) &gt; 1:
            raise ValueError(&#34;nested sublists must have equal length&#34;)

        flattened_2d = list(itertools.chain.from_iterable(data))

        if any(isinstance(i, Iterable) for i in flattened_2d):
            raise ValueError(&#34;cannot be nested deeper than list-of-lists&#34;)

        if sublengths[0] == 0:
            raise ValueError(&#34;empty&#34;)

        return 2

    def _convert_to_csv(self, data):
        &#34;&#34;&#34;Validate data and convert to a comma-separated plaintext string&#34;&#34;&#34;

        # Note: as in the Boon Nano SDK, there is no check that data dimensions
        # align with number of features and streaming window size.
        ndim = self._validate_dims(data)

        if ndim == 0:
            data_flat = [data]
        elif ndim == 1:
            data_flat = list(data)
        elif ndim == 2:
            data_flat = list(itertools.chain.from_iterable(data))

        for d in data_flat:
            if not isinstance(d, Number):
                raise ValueError(&#34;contained {} which is not numeric&#34;.format(d.__repr__()))

        return &#39;,&#39;.join([str(float(d)) for d in data_flat])

    def stream_sensor(self, sensor_id, data):
        &#34;&#34;&#34;Stream data to an amber sensor and return the inference result

        Args:
            sensor_id (str): sensor identifier
            data (array-like): data to be inferenced. Must be non-empty,
                entirely numeric and one of the following: scalar value,
                list-like or list-of-lists-like where all sublists have
                equal length.

        Returns:
            A dictionary containing inferencing results:

                {
                    &#39;state&#39;: str,
                    &#39;message&#39;: str,
                    &#39;progress&#39;: int,
                    &#39;clusterCount&#39;: int,
                    &#39;retryCount&#39;: int,
                    &#39;streamingWindowSize&#39;: int,
                    &#39;totalInferences&#39;: int,
                    &#39;ID&#39;: [int],
                    &#39;SI&#39;: [int],
                    &#39;AD&#39;: [int],
                    &#39;AH&#39;: [int],
                    &#39;AM&#39;: [float],
                    &#39;AW&#39;: [int]
                }

                &#39;state&#39;: current state of the sensor. One of:
                    &#34;Buffering&#34;: gathering initial sensor data
                    &#34;Autotuning&#34;: autotuning configuration in progress
                    &#34;Learning&#34;: sensor is active and learning
                    &#34;Monitoring&#34;: sensor is active but monitoring only (learning disabled)
                    &#34;Error&#34;: fatal error has occurred
                &#39;message&#39;: accompanying message for current sensor state
                &#39;progress&#39; progress as a percentage value (applicable for &#34;Buffering&#34; and &#34;Autotuning&#34; states)
                &#39;clusterCount&#39; number of clusters created so far
                &#39;retryCount&#39; number of times autotuning was re-attempted to tune streamingWindowSize
                &#39;streamingWindowSize&#39;: streaming window size of sensor (may differ from value
                    given at configuration if window size was adjusted during autotune)
                &#39;totalInferences&#39;: number of inferences since configuration
                &#39;ID&#39;: list of cluster IDs. The values in this list correspond one-to-one
                    with input samples, indicating the cluster to which each input pattern
                    was assigned.
                &#39;SI&#39;: smoothed anomaly index. The values in this list correspond
                    one-for-one with input samples and range between 0 and 1000. Values
                    closer to 0 represent input patterns which are ordinary given the data
                    seen so far on this sensor. Values closer to 1000 represent novel patterns
                    which are anomalous with respect to data seen before.
                &#39;AD&#39;: list of binary anomaly detection values. These correspond one-to-one
                    with input samples and are produced by thresholding the smoothed anomaly
                    index (SI). The threshold is determined automatically from the SI values.
                    A value of 0 indicates that the SI has not exceeded the anomaly detection
                    threshold. A value of 1 indicates it has, signaling an anomaly at the
                    corresponding input sample.
                &#39;AH&#39;: list of anomaly history values. These values are a moving-window sum of
                    the AD value, giving the number of anomaly detections (1&#39;s) present in the
                    AD signal over a &#34;recent history&#34; window whose length is the buffer size.
                &#39;AM&#39;: list of &#34;Amber Metric&#34; values. These are floating point values between
                    0.0 and 1.0 indicating the extent to which each corresponding AH value
                    shows an unusually high number of anomalies in recent history. The values
                    are derived statistically from a Poisson model, with values close to 0.0
                    signaling a lower, and values close to 1.0 signaling a higher, frequency
                    of anomalies than usual.
                &#39;AW&#39;: list of &#34;Amber Warning Level&#34; values. This index is produced by thresholding
                    the Amber Metric (AM) and takes on the values 0, 1 or 2 representing a discrete
                    &#34;warning level&#34; for an asset based on the frequency of anomalies within recent
                    history. 0 = normal, 1 = asset changing, 2 = asset critical. The default
                    thresholds for the two warning levels are the standard statistical values
                    of 0.95 (outlier, asset changing) and 0.997 (extreme outlier, asset critical).

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid data
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        # Server expects data as a plaintext string of comma-separated values.
        try:
            data_csv = self._convert_to_csv(data)
        except ValueError as e:
            raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

        url = self.server + &#39;/stream&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;data&#39;: data_csv
        }

        results = self._api_call(&#39;POST&#39;, url, headers, body=body)

        return results

    def get_sensor(self, sensor_id):
        &#34;&#34;&#34;Get info about a sensor

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing sensor information:

                {
                    &#39;label&#39;: str,
                    &#39;sensorId&#39;: str,
                    &#39;tenantId&#39;: str,
                    &#39;usageInfo&#39;: {
                        putSensor {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        getSensor {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        getConfig {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        postStream {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: int
                            &#39;samplesTotal&#39;: int
                            &#39;samplesThisPeriod&#39;: int
                        }
                        getStatus {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        }
                    }
                }

                &#39;label&#39; (str): sensor label
                &#39;sensorId&#39; (str): sensor identifier
                &#39;tenantId&#39; (str): username of associated Amber account
                &#39;callsTotal&#39;: total number of calls to this endpoint
                &#39;callsThisPeriod&#39;: calls this billing period to this endpoint
                &#39;lastCalled&#39;: ISO formatted time of last call to this endpoint
                &#39;samplesTotal&#39;: total number of samples processed
                &#39;samplesThisPeriod&#39;: number of samples processed this billing period

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        sensor = self._api_call(&#39;GET&#39;, url, headers)

        return sensor

    def get_config(self, sensor_id):
        &#34;&#34;&#34;Get current sensor configuration

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing the current sensor configuration:

                {
                    &#39;featureCount&#39;: int,
                    &#39;streamingWindowSize&#39;: int,
                    &#39;samplesToBuffer&#39;: int,
                    &#39;learningRateNumerator&#39;: int,
                    &#39;learningRateDenominator&#39;: int,
                    &#39;learningMaxClusters&#39;: int,
                    &#39;learningMaxSamples&#39;: int,
                    &#39;percentVariation&#39;: float,
                    &#39;features&#39;:
                    [
                        {
                            &#39;min&#39;: float,
                            &#39;max&#39;: float
                        }
                    ]
                }

                &#39;featureCount&#39;: number of features (dimensionality of each data sample)
                &#39;streamingWindowSize&#39;: streaming window size (number of samples)
                &#39;samplesToBuffer&#39;: number of samples to load before autotuning
                &#39;learningRateNumerator&#39;: sensor &#34;graduates&#34; (i.e. transitions from
                    learning to monitoring mode) if fewer than learning_rate_numerator
                    new clusters are opened in the last learning_rate_denominator samples
                &#39;learningRateDenominator&#39;: see learning_rate_numerator
                &#39;learningMaxClusters&#39;: sensor graduates if this many clusters are created
                &#39;learningMaxSamples&#39;: sensor graduates if this many samples are processed
                &#39;percentVariation&#39;: percent variation parameter discovered by autotuning
                &#39;features&#39;: min/max values per feature discovered by autotuning
        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/config&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        config = self._api_call(&#39;GET&#39;, url, headers)

        return config

    def get_status(self, sensor_id):
        &#34;&#34;&#34;Get sensor status

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing the clustering status for a sensor:

                {
                    &#39;pca&#39; [(int,int,int)],
                    &#39;clusterGrowth&#39; [int],
                    &#39;clusterSizes&#39; [int],
                    &#39;anomalyIndexes&#39; [int],
                    &#39;frequencyIndexes&#39; [int],
                    &#39;distanceIndexes&#39; [int],
                    &#39;totalInferences&#39; [int],
                    &#39;numClusters&#39; [int],
                }

                &#39;pca&#39;: list of length-3 vectors representing cluster centroids
                    with dimensionality reduced to 3 principal components. List length
                    is one plus the maximum cluster ID, with element 0 corresponding
                    to the &#34;zero&#34; cluster, element 1 corresponding to cluster ID 1, etc.
                &#39;clusterGrowth&#39;: sample index at which each new cluster was created.
                    Elements for this and other list results are ordered as in &#39;pca&#39;.
                &#39;clusterSizes&#39;: number of samples in each cluster
                &#39;anomalyIndexes&#39;: anomaly index associated with each cluster
                &#39;frequencyIndexes&#39;: frequency index associated with each cluster
                &#39;distanceIndexes&#39;: distance index associated with each cluster
                &#39;totalInferences&#39;: total number of inferences performed so far
                &#39;numClusters&#39;: number of clusters created so far (includes zero cluster)

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/status&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        status = self._api_call(&#39;GET&#39;, url, headers)

        return status</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="boonamber.AmberClient"><code class="flex name class">
<span>class <span class="ident">AmberClient</span></span>
<span>(</span><span>license_id='default', license_file='~/.Amber.license')</span>
</code></dt>
<dd>
<div class="desc"><p>Main client which interfaces with the Amber cloud. Amber account
credentials are discovered within a .Amber.license file located in the
home directory, or optionally overridden using environment variables.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>license_id</code></strong> :&ensp;<code>str</code></dt>
<dd>license identifier label found within .Amber.license file</dd>
<dt><strong><code>license_file</code></strong> :&ensp;<code>str</code></dt>
<dd>path to .Amber.license file</dd>
</dl>
<h2 id="environment">Environment</h2>
<p><code>AMBER_LICENSE_FILE</code>: sets license_file path</p>
<p><code>AMBER_LICENSE_ID</code>: sets license_id</p>
<p><code>AMBER_USERNAME</code>: overrides the username as found in .Amber.license file</p>
<p><code>AMBER_PASSWORD</code>: overrides the password as found in .Amber.license file</p>
<p><code>AMBER_SERVER</code>: overrides the server as found in .Amber.license file</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if error supplying authentication credentials</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmberClient():
    def __init__(self, license_id=&#39;default&#39;, license_file=&#34;~/.Amber.license&#34;):
        &#34;&#34;&#34;Main client which interfaces with the Amber cloud. Amber account
        credentials are discovered within a .Amber.license file located in the
        home directory, or optionally overridden using environment variables.

        Args:
            license_id (str): license identifier label found within .Amber.license file
            license_file (str): path to .Amber.license file
        
        Environment:

            `AMBER_LICENSE_FILE`: sets license_file path

            `AMBER_LICENSE_ID`: sets license_id

            `AMBER_USERNAME`: overrides the username as found in .Amber.license file

            `AMBER_PASSWORD`: overrides the password as found in .Amber.license file

            `AMBER_SERVER`: overrides the server as found in .Amber.license file

        Raises:
            AmberUserError: if error supplying authentication credentials
        &#34;&#34;&#34;

        self.token = None
        self.reauth_time = time.time()

        env_license_file = os.environ.get(&#39;AMBER_LICENSE_FILE&#39;, None)
        env_license_id = os.environ.get(&#39;AMBER_LICENSE_ID&#39;, None)
        env_username = os.environ.get(&#39;AMBER_USERNAME&#39;, None)
        env_password = os.environ.get(&#39;AMBER_PASSWORD&#39;, None)
        env_server = os.environ.get(&#39;AMBER_SERVER&#39;, None)

        # if username, password and server are all specified via environment, we&#39;re done here
        if env_username and env_password and env_server:
            self.username = env_username
            self.password = env_password
            self.server = env_server
            return

        # otherwise we acquire either or both of them from license file
        license_file = env_license_file if env_license_file else license_file
        license_id = env_license_id if env_license_id else license_id

        license_path = os.path.expanduser(license_file)
        if not os.path.exists(license_path):
            raise AmberUserError(&#34;license file {} does not exist&#34;.format(license_path))

        try:
            with open(license_path, &#39;r&#39;) as f:
                file_data = json.load(f)
        except json.JSONDecodeError as e:
            raise AmberUserError(
                &#34;JSON formatting error in license file: {}, line: {}, col: {}&#34;.format(e.msg, e.lineno, e.colno))

        try:
            license_data = file_data[license_id]
        except KeyError:
            raise AmberUserError(&#34;license_id \&#34;{}\&#34; not found in license file&#34;.format(license_id))

        # load the username, password and server, still giving precedence to environment
        try:
            self.username = env_username if env_username else license_data[&#39;username&#39;]
        except KeyError:
            raise AmberUserError(&#34;\&#34;username\&#34; is missing from the specified license in license file&#34;)

        try:
            self.password = env_password if env_password else license_data[&#39;password&#39;]
        except KeyError:
            raise AmberUserError(&#34;\&#34;password\&#34; is missing from the specified license in license file&#34;)

        try:
            self.server = env_server if env_server else license_data[&#39;server&#39;]
        except KeyError:
            raise AmberUserError(&#34;\&#34;server\&#34; is missing from the specified license in license file&#34;)

    def _authenticate(self):
        &#34;&#34;&#34;Authenticate client for the next hour using the credentials given at
        initialization. This acquires and stores an oauth2 token which remains
        valid for one hour and is used to authenticate all other API requests.

        Raises:
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/oauth2&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        body = {
            &#39;username&#39;: self.username,
            &#39;password&#39;: self.password
        }

        response = requests.request(method=&#39;POST&#39;, url=url, headers=headers, json=body)

        if response.status_code != 200:
            message = &#34;authentication failed: {}&#34;.format(response.json()[&#39;message&#39;])
            raise AmberCloudError(response.status_code, message)

        # invalid credentials return a 200 where token is an empty string
        if not response.json()[&#39;idToken&#39;]:
            raise AmberCloudError(401, &#34;authentication failed: invalid credentials&#34;)

        self.token = response.json()[&#39;idToken&#39;]

        expire_secs = int(response.json()[&#39;expiresIn&#39;])
        self.reauth_time = time.time() + expire_secs - 60

    def _api_call(self, method, url, headers, body=None):
        &#34;&#34;&#34;Make a REST call to the Amber server and handle the response&#34;&#34;&#34;

        if time.time() &gt; self.reauth_time:
            self._authenticate()

        headers[&#39;Authorization&#39;] = &#39;Bearer {}&#39;.format(self.token)
        response = requests.request(method=method, url=url, headers=headers, json=body)

        if response.status_code != 200:
            raise AmberCloudError(response.status_code, response.json()[&#39;message&#39;])

        # todo: why 200 status codes with error codes/message in body instead?
        if &#39;code&#39; in response.json() and response.json()[&#39;code&#39;] != 200:
            raise AmberCloudError(response.json()[&#39;code&#39;], response.json()[&#39;message&#39;])

        # lambda runtime errors return 200 with errorMessage in response body
        if &#39;errorMessage&#39; in response.json():
            raise AmberCloudError(500, response.json()[&#39;errorMessage&#39;])

        return response.json()

    def create_sensor(self, label=&#39;&#39;):
        &#34;&#34;&#34;Create a new sensor instance

        Args:
            label (str): label to assign to created sensor

        Returns:
            A string containing the `sensor_id` that was created

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        body = {
            &#39;label&#39;: label
        }
        response = self._api_call(&#39;POST&#39;, url, headers, body=body)
        sensor_id = response[&#39;sensorId&#39;]

        return sensor_id

    def update_label(self, sensor_id, label):
        &#34;&#34;&#34;Update the label of a sensor instance

        Args:
            sensor_id (str): sensor identifier
            label (str): new label to assign to sensor

        Returns:
            A string containing the new label assigned to sensor

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;label&#39;: label
        }
        response = self._api_call(&#39;PUT&#39;, url, headers, body=body)
        label = response[&#39;label&#39;]

        return label

    def delete_sensor(self, sensor_id):
        &#34;&#34;&#34;Delete an amber sensor instance

        Args:
            sensor_id (str): sensor identifier

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        response = self._api_call(&#39;DELETE&#39;, url, headers)

    def list_sensors(self):
        &#34;&#34;&#34;List all sensor instances currently associated with Amber account

        Returns:
            A dictionary mapping sensor IDs to corresponding labels

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensors&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }
        response = self._api_call(&#39;GET&#39;, url, headers)
        sensors = {s[&#39;sensorId&#39;]: s.get(&#39;label&#39;, None) for s in response}

        return sensors

    def configure_sensor(self, sensor_id, feature_count=1, streaming_window_size=25,
                         samples_to_buffer=10000,
                         learning_rate_numerator=10,
                         learning_rate_denominator=10000,
                         learning_max_clusters=1000,
                         learning_max_samples=1000000):
        &#34;&#34;&#34;Configure an amber sensor instance

        Args:
            sensor_id (str): sensor identifier
            feature_count (int): number of features (dimensionality of each data sample)
            streaming_window_size (int): streaming window size (number of samples)
            samples_to_buffer (int): number of samples to load before autotuning
            learning_rate_numerator (int): sensor &#34;graduates&#34; (i.e. transitions from
                learning to monitoring mode) if fewer than learning_rate_numerator
                new clusters are opened in the last learning_rate_denominator samples
            learning_rate_denominator (int): see learning_rate_numerator
            learning_max_clusters (int): sensor graduates if this many clusters are created
            learning_max_samples (int): sensor graduates if this many samples are processed

        Returns:
            A dictionary containing:

                {
                    &#39;feature_count&#39;: int,
                    &#39;streaming_window_size&#39;: int,
                    &#39;samples_to_buffer&#39;: int
                    &#39;learning_rate_numerator&#39;: int
                    &#39;learning_rate_denominator&#39;: int
                    &#39;learning_max_clusters&#39;: int
                    &#39;learning_max_samples&#39;: int
                }

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid options
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;
        if not feature_count &gt; 0 or not isinstance(feature_count, Integral):
            raise AmberUserError(&#34;invalid &#39;feature_count&#39;: must be positive integer&#34;)

        if not streaming_window_size &gt; 0 or not isinstance(streaming_window_size, Integral):
            raise AmberUserError(&#34;invalid &#39;streaming_window_size&#39;: must be positive integer&#34;)

        url = self.server + &#39;/config&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;featureCount&#39;: feature_count,
            &#39;streamingWindowSize&#39;: streaming_window_size,
            &#39;samplesToBuffer&#39;: samples_to_buffer,
            &#39;learningRateNumerator&#39;: learning_rate_numerator,
            &#39;learningRateDenominator&#39;: learning_rate_denominator,
            &#39;learningMaxClusters&#39;: learning_max_clusters,
            &#39;learningMaxSamples&#39;: learning_max_samples
        }
        config = self._api_call(&#39;POST&#39;, url, headers, body=body)

        return config

    def _isiterable(self, x):
        # consider strings non-iterable for shape validation purposes,
        # that way they are printed out whole when caught as nonnumeric
        if isinstance(x, str):
            return False

        # collections.abc docs: &#34;The only reliable way to determine
        # whether an object is iterable is to call iter(obj).&#34;
        try:
            iter(x)
        except TypeError:
            return False

        return True

    def _validate_dims(self, data):
        &#34;&#34;&#34;Validate that data is non-empty and one of the following:
           scalar value, list-like or list-of-lists-like where all
           sublists have equal length. Return 0, 1 or 2 as inferred
           number of array dimensions
        &#34;&#34;&#34;

        # not-iterable data is a single scalar data point
        if not self._isiterable(data):
            return 0

        # iterable and unnested data is a 1-d array
        if not any(self._isiterable(d) for d in data):
            if len(list(data)) == 0:
                raise ValueError(&#34;empty&#34;)

            return 1

        # iterable and nested data is 2-d array
        if not all(self._isiterable(d) for d in data):
            raise ValueError(&#34;cannot mix nested scalars and iterables&#34;)

        sublengths = [len(list(d)) for d in data]
        if len(set(sublengths)) &gt; 1:
            raise ValueError(&#34;nested sublists must have equal length&#34;)

        flattened_2d = list(itertools.chain.from_iterable(data))

        if any(isinstance(i, Iterable) for i in flattened_2d):
            raise ValueError(&#34;cannot be nested deeper than list-of-lists&#34;)

        if sublengths[0] == 0:
            raise ValueError(&#34;empty&#34;)

        return 2

    def _convert_to_csv(self, data):
        &#34;&#34;&#34;Validate data and convert to a comma-separated plaintext string&#34;&#34;&#34;

        # Note: as in the Boon Nano SDK, there is no check that data dimensions
        # align with number of features and streaming window size.
        ndim = self._validate_dims(data)

        if ndim == 0:
            data_flat = [data]
        elif ndim == 1:
            data_flat = list(data)
        elif ndim == 2:
            data_flat = list(itertools.chain.from_iterable(data))

        for d in data_flat:
            if not isinstance(d, Number):
                raise ValueError(&#34;contained {} which is not numeric&#34;.format(d.__repr__()))

        return &#39;,&#39;.join([str(float(d)) for d in data_flat])

    def stream_sensor(self, sensor_id, data):
        &#34;&#34;&#34;Stream data to an amber sensor and return the inference result

        Args:
            sensor_id (str): sensor identifier
            data (array-like): data to be inferenced. Must be non-empty,
                entirely numeric and one of the following: scalar value,
                list-like or list-of-lists-like where all sublists have
                equal length.

        Returns:
            A dictionary containing inferencing results:

                {
                    &#39;state&#39;: str,
                    &#39;message&#39;: str,
                    &#39;progress&#39;: int,
                    &#39;clusterCount&#39;: int,
                    &#39;retryCount&#39;: int,
                    &#39;streamingWindowSize&#39;: int,
                    &#39;totalInferences&#39;: int,
                    &#39;ID&#39;: [int],
                    &#39;SI&#39;: [int],
                    &#39;AD&#39;: [int],
                    &#39;AH&#39;: [int],
                    &#39;AM&#39;: [float],
                    &#39;AW&#39;: [int]
                }

                &#39;state&#39;: current state of the sensor. One of:
                    &#34;Buffering&#34;: gathering initial sensor data
                    &#34;Autotuning&#34;: autotuning configuration in progress
                    &#34;Learning&#34;: sensor is active and learning
                    &#34;Monitoring&#34;: sensor is active but monitoring only (learning disabled)
                    &#34;Error&#34;: fatal error has occurred
                &#39;message&#39;: accompanying message for current sensor state
                &#39;progress&#39; progress as a percentage value (applicable for &#34;Buffering&#34; and &#34;Autotuning&#34; states)
                &#39;clusterCount&#39; number of clusters created so far
                &#39;retryCount&#39; number of times autotuning was re-attempted to tune streamingWindowSize
                &#39;streamingWindowSize&#39;: streaming window size of sensor (may differ from value
                    given at configuration if window size was adjusted during autotune)
                &#39;totalInferences&#39;: number of inferences since configuration
                &#39;ID&#39;: list of cluster IDs. The values in this list correspond one-to-one
                    with input samples, indicating the cluster to which each input pattern
                    was assigned.
                &#39;SI&#39;: smoothed anomaly index. The values in this list correspond
                    one-for-one with input samples and range between 0 and 1000. Values
                    closer to 0 represent input patterns which are ordinary given the data
                    seen so far on this sensor. Values closer to 1000 represent novel patterns
                    which are anomalous with respect to data seen before.
                &#39;AD&#39;: list of binary anomaly detection values. These correspond one-to-one
                    with input samples and are produced by thresholding the smoothed anomaly
                    index (SI). The threshold is determined automatically from the SI values.
                    A value of 0 indicates that the SI has not exceeded the anomaly detection
                    threshold. A value of 1 indicates it has, signaling an anomaly at the
                    corresponding input sample.
                &#39;AH&#39;: list of anomaly history values. These values are a moving-window sum of
                    the AD value, giving the number of anomaly detections (1&#39;s) present in the
                    AD signal over a &#34;recent history&#34; window whose length is the buffer size.
                &#39;AM&#39;: list of &#34;Amber Metric&#34; values. These are floating point values between
                    0.0 and 1.0 indicating the extent to which each corresponding AH value
                    shows an unusually high number of anomalies in recent history. The values
                    are derived statistically from a Poisson model, with values close to 0.0
                    signaling a lower, and values close to 1.0 signaling a higher, frequency
                    of anomalies than usual.
                &#39;AW&#39;: list of &#34;Amber Warning Level&#34; values. This index is produced by thresholding
                    the Amber Metric (AM) and takes on the values 0, 1 or 2 representing a discrete
                    &#34;warning level&#34; for an asset based on the frequency of anomalies within recent
                    history. 0 = normal, 1 = asset changing, 2 = asset critical. The default
                    thresholds for the two warning levels are the standard statistical values
                    of 0.95 (outlier, asset changing) and 0.997 (extreme outlier, asset critical).

        Raises:
            AmberUserError: if client is not authenticated or supplies invalid data
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        # Server expects data as a plaintext string of comma-separated values.
        try:
            data_csv = self._convert_to_csv(data)
        except ValueError as e:
            raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

        url = self.server + &#39;/stream&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        body = {
            &#39;data&#39;: data_csv
        }

        results = self._api_call(&#39;POST&#39;, url, headers, body=body)

        return results

    def get_sensor(self, sensor_id):
        &#34;&#34;&#34;Get info about a sensor

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing sensor information:

                {
                    &#39;label&#39;: str,
                    &#39;sensorId&#39;: str,
                    &#39;tenantId&#39;: str,
                    &#39;usageInfo&#39;: {
                        putSensor {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        getSensor {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        getConfig {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        },
                        postStream {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: int
                            &#39;samplesTotal&#39;: int
                            &#39;samplesThisPeriod&#39;: int
                        }
                        getStatus {
                            &#39;callsTotal&#39;: int
                            &#39;callsThisPeriod&#39;: int
                            &#39;lastCalled&#39;: str
                        }
                    }
                }

                &#39;label&#39; (str): sensor label
                &#39;sensorId&#39; (str): sensor identifier
                &#39;tenantId&#39; (str): username of associated Amber account
                &#39;callsTotal&#39;: total number of calls to this endpoint
                &#39;callsThisPeriod&#39;: calls this billing period to this endpoint
                &#39;lastCalled&#39;: ISO formatted time of last call to this endpoint
                &#39;samplesTotal&#39;: total number of samples processed
                &#39;samplesThisPeriod&#39;: number of samples processed this billing period

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/sensor&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        sensor = self._api_call(&#39;GET&#39;, url, headers)

        return sensor

    def get_config(self, sensor_id):
        &#34;&#34;&#34;Get current sensor configuration

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing the current sensor configuration:

                {
                    &#39;featureCount&#39;: int,
                    &#39;streamingWindowSize&#39;: int,
                    &#39;samplesToBuffer&#39;: int,
                    &#39;learningRateNumerator&#39;: int,
                    &#39;learningRateDenominator&#39;: int,
                    &#39;learningMaxClusters&#39;: int,
                    &#39;learningMaxSamples&#39;: int,
                    &#39;percentVariation&#39;: float,
                    &#39;features&#39;:
                    [
                        {
                            &#39;min&#39;: float,
                            &#39;max&#39;: float
                        }
                    ]
                }

                &#39;featureCount&#39;: number of features (dimensionality of each data sample)
                &#39;streamingWindowSize&#39;: streaming window size (number of samples)
                &#39;samplesToBuffer&#39;: number of samples to load before autotuning
                &#39;learningRateNumerator&#39;: sensor &#34;graduates&#34; (i.e. transitions from
                    learning to monitoring mode) if fewer than learning_rate_numerator
                    new clusters are opened in the last learning_rate_denominator samples
                &#39;learningRateDenominator&#39;: see learning_rate_numerator
                &#39;learningMaxClusters&#39;: sensor graduates if this many clusters are created
                &#39;learningMaxSamples&#39;: sensor graduates if this many samples are processed
                &#39;percentVariation&#39;: percent variation parameter discovered by autotuning
                &#39;features&#39;: min/max values per feature discovered by autotuning
        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/config&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        config = self._api_call(&#39;GET&#39;, url, headers)

        return config

    def get_status(self, sensor_id):
        &#34;&#34;&#34;Get sensor status

        Args:
            sensor_id (str): sensor identifier

        Returns:
            A dictionary containing the clustering status for a sensor:

                {
                    &#39;pca&#39; [(int,int,int)],
                    &#39;clusterGrowth&#39; [int],
                    &#39;clusterSizes&#39; [int],
                    &#39;anomalyIndexes&#39; [int],
                    &#39;frequencyIndexes&#39; [int],
                    &#39;distanceIndexes&#39; [int],
                    &#39;totalInferences&#39; [int],
                    &#39;numClusters&#39; [int],
                }

                &#39;pca&#39;: list of length-3 vectors representing cluster centroids
                    with dimensionality reduced to 3 principal components. List length
                    is one plus the maximum cluster ID, with element 0 corresponding
                    to the &#34;zero&#34; cluster, element 1 corresponding to cluster ID 1, etc.
                &#39;clusterGrowth&#39;: sample index at which each new cluster was created.
                    Elements for this and other list results are ordered as in &#39;pca&#39;.
                &#39;clusterSizes&#39;: number of samples in each cluster
                &#39;anomalyIndexes&#39;: anomaly index associated with each cluster
                &#39;frequencyIndexes&#39;: frequency index associated with each cluster
                &#39;distanceIndexes&#39;: distance index associated with each cluster
                &#39;totalInferences&#39;: total number of inferences performed so far
                &#39;numClusters&#39;: number of clusters created so far (includes zero cluster)

        Raises:
            AmberUserError: if client is not authenticated
            AmberCloudError: if Amber cloud gives non-200 response
        &#34;&#34;&#34;

        url = self.server + &#39;/status&#39;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;sensorId&#39;: sensor_id
        }
        status = self._api_call(&#39;GET&#39;, url, headers)

        return status</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="boonamber.AmberClient.configure_sensor"><code class="name flex">
<span>def <span class="ident">configure_sensor</span></span>(<span>self, sensor_id, feature_count=1, streaming_window_size=25, samples_to_buffer=10000, learning_rate_numerator=10, learning_rate_denominator=10000, learning_max_clusters=1000, learning_max_samples=1000000)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure an amber sensor instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
<dt><strong><code>feature_count</code></strong> :&ensp;<code>int</code></dt>
<dd>number of features (dimensionality of each data sample)</dd>
<dt><strong><code>streaming_window_size</code></strong> :&ensp;<code>int</code></dt>
<dd>streaming window size (number of samples)</dd>
<dt><strong><code>samples_to_buffer</code></strong> :&ensp;<code>int</code></dt>
<dd>number of samples to load before autotuning</dd>
<dt><strong><code>learning_rate_numerator</code></strong> :&ensp;<code>int</code></dt>
<dd>sensor "graduates" (i.e. transitions from
learning to monitoring mode) if fewer than learning_rate_numerator
new clusters are opened in the last learning_rate_denominator samples</dd>
<dt><strong><code>learning_rate_denominator</code></strong> :&ensp;<code>int</code></dt>
<dd>see learning_rate_numerator</dd>
<dt><strong><code>learning_max_clusters</code></strong> :&ensp;<code>int</code></dt>
<dd>sensor graduates if this many clusters are created</dd>
<dt><strong><code>learning_max_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>sensor graduates if this many samples are processed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing:</p>
<pre><code>{
    'feature_count': int,
    'streaming_window_size': int,
    'samples_to_buffer': int
    'learning_rate_numerator': int
    'learning_rate_denominator': int
    'learning_max_clusters': int
    'learning_max_samples': int
}
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated or supplies invalid options</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_sensor(self, sensor_id, feature_count=1, streaming_window_size=25,
                     samples_to_buffer=10000,
                     learning_rate_numerator=10,
                     learning_rate_denominator=10000,
                     learning_max_clusters=1000,
                     learning_max_samples=1000000):
    &#34;&#34;&#34;Configure an amber sensor instance

    Args:
        sensor_id (str): sensor identifier
        feature_count (int): number of features (dimensionality of each data sample)
        streaming_window_size (int): streaming window size (number of samples)
        samples_to_buffer (int): number of samples to load before autotuning
        learning_rate_numerator (int): sensor &#34;graduates&#34; (i.e. transitions from
            learning to monitoring mode) if fewer than learning_rate_numerator
            new clusters are opened in the last learning_rate_denominator samples
        learning_rate_denominator (int): see learning_rate_numerator
        learning_max_clusters (int): sensor graduates if this many clusters are created
        learning_max_samples (int): sensor graduates if this many samples are processed

    Returns:
        A dictionary containing:

            {
                &#39;feature_count&#39;: int,
                &#39;streaming_window_size&#39;: int,
                &#39;samples_to_buffer&#39;: int
                &#39;learning_rate_numerator&#39;: int
                &#39;learning_rate_denominator&#39;: int
                &#39;learning_max_clusters&#39;: int
                &#39;learning_max_samples&#39;: int
            }

    Raises:
        AmberUserError: if client is not authenticated or supplies invalid options
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;
    if not feature_count &gt; 0 or not isinstance(feature_count, Integral):
        raise AmberUserError(&#34;invalid &#39;feature_count&#39;: must be positive integer&#34;)

    if not streaming_window_size &gt; 0 or not isinstance(streaming_window_size, Integral):
        raise AmberUserError(&#34;invalid &#39;streaming_window_size&#39;: must be positive integer&#34;)

    url = self.server + &#39;/config&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    body = {
        &#39;featureCount&#39;: feature_count,
        &#39;streamingWindowSize&#39;: streaming_window_size,
        &#39;samplesToBuffer&#39;: samples_to_buffer,
        &#39;learningRateNumerator&#39;: learning_rate_numerator,
        &#39;learningRateDenominator&#39;: learning_rate_denominator,
        &#39;learningMaxClusters&#39;: learning_max_clusters,
        &#39;learningMaxSamples&#39;: learning_max_samples
    }
    config = self._api_call(&#39;POST&#39;, url, headers, body=body)

    return config</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.create_sensor"><code class="name flex">
<span>def <span class="ident">create_sensor</span></span>(<span>self, label='')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new sensor instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>label to assign to created sensor</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing the <code>sensor_id</code> that was created</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_sensor(self, label=&#39;&#39;):
    &#34;&#34;&#34;Create a new sensor instance

    Args:
        label (str): label to assign to created sensor

    Returns:
        A string containing the `sensor_id` that was created

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.server + &#39;/sensor&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;
    }
    body = {
        &#39;label&#39;: label
    }
    response = self._api_call(&#39;POST&#39;, url, headers, body=body)
    sensor_id = response[&#39;sensorId&#39;]

    return sensor_id</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.delete_sensor"><code class="name flex">
<span>def <span class="ident">delete_sensor</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete an amber sensor instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_sensor(self, sensor_id):
    &#34;&#34;&#34;Delete an amber sensor instance

    Args:
        sensor_id (str): sensor identifier

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.server + &#39;/sensor&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    response = self._api_call(&#39;DELETE&#39;, url, headers)</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current sensor configuration</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing the current sensor configuration:</p>
<pre><code>{
    'featureCount': int,
    'streamingWindowSize': int,
    'samplesToBuffer': int,
    'learningRateNumerator': int,
    'learningRateDenominator': int,
    'learningMaxClusters': int,
    'learningMaxSamples': int,
    'percentVariation': float,
    'features':
    [
        {
            'min': float,
            'max': float
        }
    ]
}

'featureCount': number of features (dimensionality of each data sample)
'streamingWindowSize': streaming window size (number of samples)
'samplesToBuffer': number of samples to load before autotuning
'learningRateNumerator': sensor "graduates" (i.e. transitions from
    learning to monitoring mode) if fewer than learning_rate_numerator
    new clusters are opened in the last learning_rate_denominator samples
'learningRateDenominator': see learning_rate_numerator
'learningMaxClusters': sensor graduates if this many clusters are created
'learningMaxSamples': sensor graduates if this many samples are processed
'percentVariation': percent variation parameter discovered by autotuning
'features': min/max values per feature discovered by autotuning
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self, sensor_id):
    &#34;&#34;&#34;Get current sensor configuration

    Args:
        sensor_id (str): sensor identifier

    Returns:
        A dictionary containing the current sensor configuration:

            {
                &#39;featureCount&#39;: int,
                &#39;streamingWindowSize&#39;: int,
                &#39;samplesToBuffer&#39;: int,
                &#39;learningRateNumerator&#39;: int,
                &#39;learningRateDenominator&#39;: int,
                &#39;learningMaxClusters&#39;: int,
                &#39;learningMaxSamples&#39;: int,
                &#39;percentVariation&#39;: float,
                &#39;features&#39;:
                [
                    {
                        &#39;min&#39;: float,
                        &#39;max&#39;: float
                    }
                ]
            }

            &#39;featureCount&#39;: number of features (dimensionality of each data sample)
            &#39;streamingWindowSize&#39;: streaming window size (number of samples)
            &#39;samplesToBuffer&#39;: number of samples to load before autotuning
            &#39;learningRateNumerator&#39;: sensor &#34;graduates&#34; (i.e. transitions from
                learning to monitoring mode) if fewer than learning_rate_numerator
                new clusters are opened in the last learning_rate_denominator samples
            &#39;learningRateDenominator&#39;: see learning_rate_numerator
            &#39;learningMaxClusters&#39;: sensor graduates if this many clusters are created
            &#39;learningMaxSamples&#39;: sensor graduates if this many samples are processed
            &#39;percentVariation&#39;: percent variation parameter discovered by autotuning
            &#39;features&#39;: min/max values per feature discovered by autotuning
    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.server + &#39;/config&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    config = self._api_call(&#39;GET&#39;, url, headers)

    return config</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_sensor"><code class="name flex">
<span>def <span class="ident">get_sensor</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get info about a sensor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing sensor information:</p>
<pre><code>{
    'label': str,
    'sensorId': str,
    'tenantId': str,
    'usageInfo': {
        putSensor {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': str
        },
        getSensor {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': str
        },
        getConfig {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': str
        },
        postStream {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': int
            'samplesTotal': int
            'samplesThisPeriod': int
        }
        getStatus {
            'callsTotal': int
            'callsThisPeriod': int
            'lastCalled': str
        }
    }
}

'label' (str): sensor label
'sensorId' (str): sensor identifier
'tenantId' (str): username of associated Amber account
'callsTotal': total number of calls to this endpoint
'callsThisPeriod': calls this billing period to this endpoint
'lastCalled': ISO formatted time of last call to this endpoint
'samplesTotal': total number of samples processed
'samplesThisPeriod': number of samples processed this billing period
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sensor(self, sensor_id):
    &#34;&#34;&#34;Get info about a sensor

    Args:
        sensor_id (str): sensor identifier

    Returns:
        A dictionary containing sensor information:

            {
                &#39;label&#39;: str,
                &#39;sensorId&#39;: str,
                &#39;tenantId&#39;: str,
                &#39;usageInfo&#39;: {
                    putSensor {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: str
                    },
                    getSensor {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: str
                    },
                    getConfig {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: str
                    },
                    postStream {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: int
                        &#39;samplesTotal&#39;: int
                        &#39;samplesThisPeriod&#39;: int
                    }
                    getStatus {
                        &#39;callsTotal&#39;: int
                        &#39;callsThisPeriod&#39;: int
                        &#39;lastCalled&#39;: str
                    }
                }
            }

            &#39;label&#39; (str): sensor label
            &#39;sensorId&#39; (str): sensor identifier
            &#39;tenantId&#39; (str): username of associated Amber account
            &#39;callsTotal&#39;: total number of calls to this endpoint
            &#39;callsThisPeriod&#39;: calls this billing period to this endpoint
            &#39;lastCalled&#39;: ISO formatted time of last call to this endpoint
            &#39;samplesTotal&#39;: total number of samples processed
            &#39;samplesThisPeriod&#39;: number of samples processed this billing period

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.server + &#39;/sensor&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    sensor = self._api_call(&#39;GET&#39;, url, headers)

    return sensor</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, sensor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get sensor status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing the clustering status for a sensor:</p>
<pre><code>{
    'pca' [(int,int,int)],
    'clusterGrowth' [int],
    'clusterSizes' [int],
    'anomalyIndexes' [int],
    'frequencyIndexes' [int],
    'distanceIndexes' [int],
    'totalInferences' [int],
    'numClusters' [int],
}

'pca': list of length-3 vectors representing cluster centroids
    with dimensionality reduced to 3 principal components. List length
    is one plus the maximum cluster ID, with element 0 corresponding
    to the "zero" cluster, element 1 corresponding to cluster ID 1, etc.
'clusterGrowth': sample index at which each new cluster was created.
    Elements for this and other list results are ordered as in 'pca'.
'clusterSizes': number of samples in each cluster
'anomalyIndexes': anomaly index associated with each cluster
'frequencyIndexes': frequency index associated with each cluster
'distanceIndexes': distance index associated with each cluster
'totalInferences': total number of inferences performed so far
'numClusters': number of clusters created so far (includes zero cluster)
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self, sensor_id):
    &#34;&#34;&#34;Get sensor status

    Args:
        sensor_id (str): sensor identifier

    Returns:
        A dictionary containing the clustering status for a sensor:

            {
                &#39;pca&#39; [(int,int,int)],
                &#39;clusterGrowth&#39; [int],
                &#39;clusterSizes&#39; [int],
                &#39;anomalyIndexes&#39; [int],
                &#39;frequencyIndexes&#39; [int],
                &#39;distanceIndexes&#39; [int],
                &#39;totalInferences&#39; [int],
                &#39;numClusters&#39; [int],
            }

            &#39;pca&#39;: list of length-3 vectors representing cluster centroids
                with dimensionality reduced to 3 principal components. List length
                is one plus the maximum cluster ID, with element 0 corresponding
                to the &#34;zero&#34; cluster, element 1 corresponding to cluster ID 1, etc.
            &#39;clusterGrowth&#39;: sample index at which each new cluster was created.
                Elements for this and other list results are ordered as in &#39;pca&#39;.
            &#39;clusterSizes&#39;: number of samples in each cluster
            &#39;anomalyIndexes&#39;: anomaly index associated with each cluster
            &#39;frequencyIndexes&#39;: frequency index associated with each cluster
            &#39;distanceIndexes&#39;: distance index associated with each cluster
            &#39;totalInferences&#39;: total number of inferences performed so far
            &#39;numClusters&#39;: number of clusters created so far (includes zero cluster)

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.server + &#39;/status&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    status = self._api_call(&#39;GET&#39;, url, headers)

    return status</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.list_sensors"><code class="name flex">
<span>def <span class="ident">list_sensors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List all sensor instances currently associated with Amber account</p>
<h2 id="returns">Returns</h2>
<p>A dictionary mapping sensor IDs to corresponding labels</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_sensors(self):
    &#34;&#34;&#34;List all sensor instances currently associated with Amber account

    Returns:
        A dictionary mapping sensor IDs to corresponding labels

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.server + &#39;/sensors&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;
    }
    response = self._api_call(&#39;GET&#39;, url, headers)
    sensors = {s[&#39;sensorId&#39;]: s.get(&#39;label&#39;, None) for s in response}

    return sensors</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.stream_sensor"><code class="name flex">
<span>def <span class="ident">stream_sensor</span></span>(<span>self, sensor_id, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Stream data to an amber sensor and return the inference result</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>array-like</code></dt>
<dd>data to be inferenced. Must be non-empty,
entirely numeric and one of the following: scalar value,
list-like or list-of-lists-like where all sublists have
equal length.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing inferencing results:</p>
<pre><code>{
    'state': str,
    'message': str,
    'progress': int,
    'clusterCount': int,
    'retryCount': int,
    'streamingWindowSize': int,
    'totalInferences': int,
    'ID': [int],
    'SI': [int],
    'AD': [int],
    'AH': [int],
    'AM': [float],
    'AW': [int]
}

'state': current state of the sensor. One of:
    "Buffering": gathering initial sensor data
    "Autotuning": autotuning configuration in progress
    "Learning": sensor is active and learning
    "Monitoring": sensor is active but monitoring only (learning disabled)
    "Error": fatal error has occurred
'message': accompanying message for current sensor state
'progress' progress as a percentage value (applicable for "Buffering" and "Autotuning" states)
'clusterCount' number of clusters created so far
'retryCount' number of times autotuning was re-attempted to tune streamingWindowSize
'streamingWindowSize': streaming window size of sensor (may differ from value
    given at configuration if window size was adjusted during autotune)
'totalInferences': number of inferences since configuration
'ID': list of cluster IDs. The values in this list correspond one-to-one
    with input samples, indicating the cluster to which each input pattern
    was assigned.
'SI': smoothed anomaly index. The values in this list correspond
    one-for-one with input samples and range between 0 and 1000. Values
    closer to 0 represent input patterns which are ordinary given the data
    seen so far on this sensor. Values closer to 1000 represent novel patterns
    which are anomalous with respect to data seen before.
'AD': list of binary anomaly detection values. These correspond one-to-one
    with input samples and are produced by thresholding the smoothed anomaly
    index (SI). The threshold is determined automatically from the SI values.
    A value of 0 indicates that the SI has not exceeded the anomaly detection
    threshold. A value of 1 indicates it has, signaling an anomaly at the
    corresponding input sample.
'AH': list of anomaly history values. These values are a moving-window sum of
    the AD value, giving the number of anomaly detections (1's) present in the
    AD signal over a "recent history" window whose length is the buffer size.
'AM': list of "Amber Metric" values. These are floating point values between
    0.0 and 1.0 indicating the extent to which each corresponding AH value
    shows an unusually high number of anomalies in recent history. The values
    are derived statistically from a Poisson model, with values close to 0.0
    signaling a lower, and values close to 1.0 signaling a higher, frequency
    of anomalies than usual.
'AW': list of "Amber Warning Level" values. This index is produced by thresholding
    the Amber Metric (AM) and takes on the values 0, 1 or 2 representing a discrete
    "warning level" for an asset based on the frequency of anomalies within recent
    history. 0 = normal, 1 = asset changing, 2 = asset critical. The default
    thresholds for the two warning levels are the standard statistical values
    of 0.95 (outlier, asset changing) and 0.997 (extreme outlier, asset critical).
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated or supplies invalid data</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_sensor(self, sensor_id, data):
    &#34;&#34;&#34;Stream data to an amber sensor and return the inference result

    Args:
        sensor_id (str): sensor identifier
        data (array-like): data to be inferenced. Must be non-empty,
            entirely numeric and one of the following: scalar value,
            list-like or list-of-lists-like where all sublists have
            equal length.

    Returns:
        A dictionary containing inferencing results:

            {
                &#39;state&#39;: str,
                &#39;message&#39;: str,
                &#39;progress&#39;: int,
                &#39;clusterCount&#39;: int,
                &#39;retryCount&#39;: int,
                &#39;streamingWindowSize&#39;: int,
                &#39;totalInferences&#39;: int,
                &#39;ID&#39;: [int],
                &#39;SI&#39;: [int],
                &#39;AD&#39;: [int],
                &#39;AH&#39;: [int],
                &#39;AM&#39;: [float],
                &#39;AW&#39;: [int]
            }

            &#39;state&#39;: current state of the sensor. One of:
                &#34;Buffering&#34;: gathering initial sensor data
                &#34;Autotuning&#34;: autotuning configuration in progress
                &#34;Learning&#34;: sensor is active and learning
                &#34;Monitoring&#34;: sensor is active but monitoring only (learning disabled)
                &#34;Error&#34;: fatal error has occurred
            &#39;message&#39;: accompanying message for current sensor state
            &#39;progress&#39; progress as a percentage value (applicable for &#34;Buffering&#34; and &#34;Autotuning&#34; states)
            &#39;clusterCount&#39; number of clusters created so far
            &#39;retryCount&#39; number of times autotuning was re-attempted to tune streamingWindowSize
            &#39;streamingWindowSize&#39;: streaming window size of sensor (may differ from value
                given at configuration if window size was adjusted during autotune)
            &#39;totalInferences&#39;: number of inferences since configuration
            &#39;ID&#39;: list of cluster IDs. The values in this list correspond one-to-one
                with input samples, indicating the cluster to which each input pattern
                was assigned.
            &#39;SI&#39;: smoothed anomaly index. The values in this list correspond
                one-for-one with input samples and range between 0 and 1000. Values
                closer to 0 represent input patterns which are ordinary given the data
                seen so far on this sensor. Values closer to 1000 represent novel patterns
                which are anomalous with respect to data seen before.
            &#39;AD&#39;: list of binary anomaly detection values. These correspond one-to-one
                with input samples and are produced by thresholding the smoothed anomaly
                index (SI). The threshold is determined automatically from the SI values.
                A value of 0 indicates that the SI has not exceeded the anomaly detection
                threshold. A value of 1 indicates it has, signaling an anomaly at the
                corresponding input sample.
            &#39;AH&#39;: list of anomaly history values. These values are a moving-window sum of
                the AD value, giving the number of anomaly detections (1&#39;s) present in the
                AD signal over a &#34;recent history&#34; window whose length is the buffer size.
            &#39;AM&#39;: list of &#34;Amber Metric&#34; values. These are floating point values between
                0.0 and 1.0 indicating the extent to which each corresponding AH value
                shows an unusually high number of anomalies in recent history. The values
                are derived statistically from a Poisson model, with values close to 0.0
                signaling a lower, and values close to 1.0 signaling a higher, frequency
                of anomalies than usual.
            &#39;AW&#39;: list of &#34;Amber Warning Level&#34; values. This index is produced by thresholding
                the Amber Metric (AM) and takes on the values 0, 1 or 2 representing a discrete
                &#34;warning level&#34; for an asset based on the frequency of anomalies within recent
                history. 0 = normal, 1 = asset changing, 2 = asset critical. The default
                thresholds for the two warning levels are the standard statistical values
                of 0.95 (outlier, asset changing) and 0.997 (extreme outlier, asset critical).

    Raises:
        AmberUserError: if client is not authenticated or supplies invalid data
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    # Server expects data as a plaintext string of comma-separated values.
    try:
        data_csv = self._convert_to_csv(data)
    except ValueError as e:
        raise AmberUserError(&#34;invalid data: {}&#34;.format(e))

    url = self.server + &#39;/stream&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    body = {
        &#39;data&#39;: data_csv
    }

    results = self._api_call(&#39;POST&#39;, url, headers, body=body)

    return results</code></pre>
</details>
</dd>
<dt id="boonamber.AmberClient.update_label"><code class="name flex">
<span>def <span class="ident">update_label</span></span>(<span>self, sensor_id, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the label of a sensor instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sensor_id</code></strong> :&ensp;<code>str</code></dt>
<dd>sensor identifier</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>new label to assign to sensor</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing the new label assigned to sensor</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></dt>
<dd>if client is not authenticated</dd>
<dt><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></dt>
<dd>if Amber cloud gives non-200 response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_label(self, sensor_id, label):
    &#34;&#34;&#34;Update the label of a sensor instance

    Args:
        sensor_id (str): sensor identifier
        label (str): new label to assign to sensor

    Returns:
        A string containing the new label assigned to sensor

    Raises:
        AmberUserError: if client is not authenticated
        AmberCloudError: if Amber cloud gives non-200 response
    &#34;&#34;&#34;

    url = self.server + &#39;/sensor&#39;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;sensorId&#39;: sensor_id
    }
    body = {
        &#39;label&#39;: label
    }
    response = self._api_call(&#39;PUT&#39;, url, headers, body=body)
    label = response[&#39;label&#39;]

    return label</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="boonamber.AmberCloudError"><code class="flex name class">
<span>class <span class="ident">AmberCloudError</span></span>
<span>(</span><span>code, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised upon any non-200 response from the Amber cloud</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmberCloudError(Exception):
    &#34;&#34;&#34;Raised upon any non-200 response from the Amber cloud&#34;&#34;&#34;

    def __init__(self, code, message):
        self.code = code
        self.message = message
        super().__init__(&#34;{}: {}&#34;.format(code, message))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="boonamber.AmberUserError"><code class="flex name class">
<span>class <span class="ident">AmberUserError</span></span>
<span>(</span><span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised to indicate an error in SDK usage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmberUserError(Exception):
    &#34;&#34;&#34;Raised to indicate an error in SDK usage&#34;&#34;&#34;

    def __init__(self, message):
        self.message = message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="boonamber.AmberClient" href="#boonamber.AmberClient">AmberClient</a></code></h4>
<ul class="two-column">
<li><code><a title="boonamber.AmberClient.configure_sensor" href="#boonamber.AmberClient.configure_sensor">configure_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.create_sensor" href="#boonamber.AmberClient.create_sensor">create_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.delete_sensor" href="#boonamber.AmberClient.delete_sensor">delete_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.get_config" href="#boonamber.AmberClient.get_config">get_config</a></code></li>
<li><code><a title="boonamber.AmberClient.get_sensor" href="#boonamber.AmberClient.get_sensor">get_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.get_status" href="#boonamber.AmberClient.get_status">get_status</a></code></li>
<li><code><a title="boonamber.AmberClient.list_sensors" href="#boonamber.AmberClient.list_sensors">list_sensors</a></code></li>
<li><code><a title="boonamber.AmberClient.stream_sensor" href="#boonamber.AmberClient.stream_sensor">stream_sensor</a></code></li>
<li><code><a title="boonamber.AmberClient.update_label" href="#boonamber.AmberClient.update_label">update_label</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="boonamber.AmberCloudError" href="#boonamber.AmberCloudError">AmberCloudError</a></code></h4>
</li>
<li>
<h4><code><a title="boonamber.AmberUserError" href="#boonamber.AmberUserError">AmberUserError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>